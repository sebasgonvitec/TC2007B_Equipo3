"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MultiViewCalendar = exports.MultiViewCalendarPropsContext = exports.MultiViewCalendarWithoutContext = void 0;
var React = require("react");
var PropTypes = require("prop-types");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var kendo_date_math_1 = require("@progress/kendo-date-math");
var kendo_react_buttons_1 = require("@progress/kendo-react-buttons");
var models_1 = require("../models");
var Header_1 = require("./Header");
var defaults_1 = require("../../defaults");
var messages_1 = require("../../messages");
var services_1 = require("../services");
var utils_1 = require("../../utils");
var HorizontalViewList_1 = require("./HorizontalViewList");
var TodayCommand_1 = require("./TodayCommand");
var extractDateFromValue = function (min, max, value) {
    if (min === void 0) { min = MultiViewCalendarWithoutContext.defaultProps.min; }
    if (max === void 0) { max = MultiViewCalendarWithoutContext.defaultProps.max; }
    return value instanceof Date && !Array.isArray(value) && (0, utils_1.isInRange)((0, kendo_date_math_1.getDate)(value), min, max)
        ? (0, kendo_date_math_1.getDate)(value)
        : null;
};
var extractMultipleFromValue = function (min, max, value) {
    if (min === void 0) { min = MultiViewCalendarWithoutContext.defaultProps.min; }
    if (max === void 0) { max = MultiViewCalendarWithoutContext.defaultProps.max; }
    return Array.isArray(value)
        ? value.filter(function (date) { return (0, utils_1.isInRange)(date, min, max); }).map(function (date) { return (0, kendo_date_math_1.getDate)(date); })
        : null;
};
var extractRangeFromValue = function (value) {
    return typeof value === 'object' && !(value instanceof Date) && value !== null && !Array.isArray(value)
        ? value
        : models_1.EMPTY_SELECTIONRANGE;
};
var extractFocusedDate = function (single, multiple, range) {
    return single || (multiple && multiple[0]) || (range && range.start);
};
var extractActiveRange = function (range, single) {
    return range.start === null && single === null
        ? 'start'
        : range.end === null
            ? 'end'
            : 'start';
};
/** @hidden */
var MultiViewCalendarWithoutContext = /** @class */ (function (_super) {
    __extends(MultiViewCalendarWithoutContext, _super);
    function MultiViewCalendarWithoutContext(props) {
        var _this = _super.call(this, props) || this;
        _this.dates = [];
        _this.selectedDate = null;
        _this.selectedMultiple = null;
        _this.selectedRange = models_1.EMPTY_SELECTIONRANGE;
        _this._focusedDate = new Date();
        _this.cellUID = (0, kendo_react_common_1.guid)();
        _this.activeRangeEnd = 'start';
        _this._element = null;
        _this.intl = null;
        _this.localization = null;
        _this.service = null;
        _this.wrapperID = (0, kendo_react_common_1.guid)();
        _this.calendarViewList = null;
        _this.isActive = false;
        _this.calculateFocusFromValue = true;
        /**
         * @hidden
         */
        _this.focus = function () {
            if (_this._element) {
                _this._element.focus();
            }
        };
        _this.clampRange = function (value) { return ({ start: value, end: null }); };
        _this.rangeWithFocused = function (range, focusedDate) {
            return {
                start: range.start,
                end: range.end === null && range.start !== null && _this.isActive ? focusedDate : range.end
            };
        };
        _this.generateRange = function (candidate, value) {
            var end = value.end, start = value.start;
            var shouldSwap = value.start !== null && candidate.getTime() <= value.start.getTime();
            if (!_this.props.allowReverse && shouldSwap) {
                return { start: candidate, end: _this.selectedRange.start };
            }
            return _this.activeRange !== 'end'
                ? ({ start: candidate, end: end })
                : ({ start: start || _this.selectedDate, end: candidate });
        };
        _this.canNavigate = function (action) {
            if (!_this.service) {
                return false;
            }
            var candidate = _this.service.move(_this.focusedDate, action);
            return (_this.min <= candidate && candidate <= _this.max)
                || _this.service.isInSameView(candidate, _this.min)
                || _this.service.isInSameView(candidate, _this.max);
        };
        _this.isListInRange = function (list) {
            return _this.min < list[0]
                && _this.max > list[Math.max(0, (_this.props.views || MultiViewCalendarWithoutContext.defaultProps.views) - 1)];
        };
        _this.navigate = function (action) {
            _this.calculateFocusFromValue = false;
            var candidate = _this.move(action);
            _this.setState({ focusedDate: candidate });
        };
        _this.move = function (action) {
            return _this.clampDate(_this.service.move(_this.focusedDate, action));
        };
        _this.clampDate = function (value) {
            return (0, utils_1.dateInRange)(value, _this.min, _this.max);
        };
        _this.shouldAutoCorrect = function (candidate, value) {
            var end = value.end, start = value.start;
            if (_this.activeRange !== 'end') {
                return end !== null && candidate > end;
            }
            else {
                return start !== null && candidate < start;
            }
        };
        _this.handleCellEnter = function (value) {
            if (_this.props.mode === 'range') {
                _this.calculateFocusFromValue = false;
                _this.setState({
                    focusedDate: value
                });
            }
        };
        _this.handleMouseDown = function (event) {
            event.preventDefault();
        };
        _this.handleClick = function (_) {
            if (!_this._element) {
                return;
            }
            _this._element.focus({ preventScroll: true });
        };
        _this.handleFocus = function (event) {
            _this.isActive = true;
            if (!_this.calendarViewList) {
                return;
            }
            _this.calendarViewList.focusActiveDate();
            var onFocus = _this.props.onFocus;
            if (onFocus) {
                onFocus.call(undefined, event);
            }
        };
        _this.handleBlur = function (event) {
            _this.isActive = false;
            if (!_this.calendarViewList) {
                return;
            }
            _this.calendarViewList.blurActiveDate();
            var onBlur = _this.props.onBlur;
            if (onBlur) {
                onBlur.call(undefined, event);
            }
        };
        _this.handleTodayClick = function (event) {
            if (!_this.todayIsInRange) {
                return;
            }
            _this.handleDateChange(event);
        };
        _this.handlePrevButtonClick = function () {
            _this.navigate(models_1.Action.PrevView);
        };
        _this.handleNextButtonClick = function () {
            _this.navigate(models_1.Action.NextView);
        };
        _this.handleKeyDown = function (event) {
            var keyCode = event.keyCode;
            if (keyCode === kendo_react_common_1.Keys.enter) {
                var args = {
                    syntheticEvent: event,
                    nativeEvent: event.nativeEvent,
                    value: _this.focusedDate,
                    target: _this
                };
                _this.handleDateChange(args);
            }
            else {
                var candidate = (0, utils_1.dateInRange)(_this.navigation.move(_this.focusedDate, _this.navigation.action(event), _this.state.activeView, _this.service, event), _this.min, _this.max);
                if ((0, kendo_date_math_1.isEqualDate)(_this.focusedDate, candidate)) {
                    return;
                }
                _this.calculateFocusFromValue = false;
                _this.setState({ focusedDate: candidate });
            }
            event.preventDefault();
        };
        _this.handleViewChange = function (_a) {
            var view = _a.view;
            _this.calculateFocusFromValue = false;
            _this.setState({ activeView: view });
        };
        _this.handleDateChange = function (event) {
            var focusedDate = (0, kendo_date_math_1.cloneDate)(event.value);
            var canNavigateDown = _this.bus.canMoveDown(_this.state.activeView);
            if (_this.props.disabled) {
                return;
            }
            if (canNavigateDown) {
                if (event.isTodayClick) {
                    _this.bus.moveToBottom(_this.state.activeView);
                }
                else {
                    _this.bus.moveDown(_this.state.activeView, event.syntheticEvent);
                    _this.setState({ focusedDate: focusedDate });
                    return;
                }
            }
            _this.calculateFocusFromValue = true;
            var value;
            switch (_this.props.mode) {
                case 'single':
                    value = (0, kendo_date_math_1.cloneDate)(event.value);
                    break;
                case 'multiple':
                    if (Array.isArray(_this.selectedMultiple)) {
                        var result = _this.selectedMultiple.slice();
                        var index_1 = -1;
                        result.forEach(function (date, idx) {
                            if ((0, kendo_date_math_1.isEqualDate)(date, event.value)) {
                                index_1 = idx;
                            }
                        });
                        index_1 !== -1
                            ? result.splice(index_1, 1)
                            : result.push((0, kendo_date_math_1.cloneDate)(event.value));
                        value = result.slice();
                    }
                    else {
                        if (_this.selectedDate) {
                            value = [(0, kendo_date_math_1.cloneDate)(_this.selectedDate), (0, kendo_date_math_1.cloneDate)(event.value)];
                        }
                        else {
                            value = [(0, kendo_date_math_1.cloneDate)(event.value)];
                        }
                    }
                    break;
                case 'range':
                    var hasSelection = _this.selectedRange.start !== null
                        && _this.selectedRange.end !== null
                        && _this.activeRange === 'start';
                    value = hasSelection
                        ? _this.clampRange(event.value)
                        : _this.generateRange(event.value, _this.selectedRange);
                    _this.activeRangeEnd = _this.activeRange !== 'end' ? 'end' : 'start';
                    break;
                default:
                    value = (0, kendo_date_math_1.cloneDate)(event.value);
                    break;
            }
            _this.valueDuringOnChange = value;
            _this.setState({ value: value, focusedDate: focusedDate });
            _this.valueDuringOnChange = value;
            var onChange = _this.props.onChange;
            if (onChange) {
                var args = {
                    syntheticEvent: event.syntheticEvent,
                    nativeEvent: event.nativeEvent,
                    value: value,
                    target: _this
                };
                onChange.call(undefined, args);
            }
            _this.valueDuringOnChange = undefined;
        };
        var value = props.value !== undefined
            ? props.value
            : props.defaultValue || MultiViewCalendarWithoutContext.defaultProps.defaultValue;
        var selectedDate = extractDateFromValue(_this.min, _this.max, value);
        var selectedMultiple = extractMultipleFromValue(_this.min, _this.max, value);
        var selectedRange = extractRangeFromValue(value);
        var calculatedFocus = extractFocusedDate(selectedDate, selectedMultiple, selectedRange);
        var activeView = (0, utils_1.viewInRange)(models_1.CalendarViewEnum[props.defaultActiveView], _this.bottomView, _this.topView);
        var focusedDate = (0, utils_1.dateInRange)(props.focusedDate || calculatedFocus || (0, utils_1.getToday)(), _this.min, _this.max);
        _this.state = {
            value: value,
            activeView: activeView,
            focusedDate: focusedDate
        };
        _this.activeRangeEnd = extractActiveRange(selectedRange, selectedDate);
        _this.bus = new services_1.BusViewService(_this.handleViewChange);
        _this.navigation = new services_1.NavigationService(_this.bus);
        _this.calculateFocusFromValue = false;
        _this.lastView = activeView;
        _this.lastViewsCount = _this.props.views || HorizontalViewList_1.HorizontalViewList.defaultProps.views;
        return _this;
    }
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "element", {
        /**
         * Gets the wrapping element of the MultiViewCalendar component.
         */
        get: function () {
            return this._element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "value", {
        /**
         * Gets the value of the MultiViewCalendar.
         */
        get: function () {
            return this.valueDuringOnChange !== undefined
                ? this.valueDuringOnChange
                : this.props.value !== undefined
                    ? this.props.value
                    : this.state.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "focusedDate", {
        /**
         * Gets the current focused date of the MultiViewCalendar.
         */
        get: function () {
            return (0, kendo_date_math_1.cloneDate)(this._focusedDate);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "min", {
        get: function () {
            return (0, kendo_date_math_1.getDate)(this.props.min !== undefined
                ? this.props.min
                : MultiViewCalendarWithoutContext.defaultProps.min);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "max", {
        get: function () {
            return (0, kendo_date_math_1.getDate)(this.props.max !== undefined
                ? this.props.max
                : MultiViewCalendarWithoutContext.defaultProps.max);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "bottomView", {
        get: function () {
            return models_1.CalendarViewEnum[this.props.bottomView !== undefined
                ? this.props.bottomView
                : MultiViewCalendarWithoutContext.defaultProps.bottomView];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "topView", {
        get: function () {
            return models_1.CalendarViewEnum[this.props.topView !== undefined
                ? this.props.topView
                : MultiViewCalendarWithoutContext.defaultProps.topView];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "activeRange", {
        get: function () {
            return this.props.activeRangeEnd !== undefined
                ? this.props.activeRangeEnd
                : this.activeRangeEnd;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "todayIsInRange", {
        get: function () {
            return (0, utils_1.isInRange)((0, utils_1.getToday)(), (0, kendo_date_math_1.getDate)(this.min), (0, kendo_date_math_1.getDate)(this.max));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.prototype.componentDidMount = function () {
        this.calculateFocusFromValue = true;
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.prototype.componentDidUpdate = function () {
        if (this.calendarViewList) {
            (this.isActive ? this.calendarViewList.focusActiveDate : this.calendarViewList.blurActiveDate)();
        }
        var stateValue = extractDateFromValue(this.min, this.max, this.value);
        this.calculateFocusFromValue = Boolean(this.selectedDate
            && stateValue
            && (this.selectedDate.getTime() && stateValue.getTime()));
        this.lastView = this.state.activeView;
        this.lastViewsCount = this.props.views || HorizontalViewList_1.HorizontalViewList.defaultProps.views;
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.prototype.render = function () {
        var _this = this;
        if (this.props._ref) {
            this.props._ref(this);
        }
        this.intl = (0, kendo_react_intl_1.provideIntlService)(this);
        this.localization = (0, kendo_react_intl_1.provideLocalizationService)(this);
        this.bus.configure(this.bottomView, this.topView);
        var activeView = (0, utils_1.viewInRange)(this.state.activeView, this.bottomView, this.topView);
        this.service = this.bus.service(activeView, this.intl);
        this.selectedDate = extractDateFromValue(this.min, this.max, this.value);
        this.selectedMultiple = extractMultipleFromValue(this.min, this.max, this.value);
        this.selectedRange = extractRangeFromValue(this.value);
        var calculatedFocus = extractFocusedDate(this.selectedDate, this.selectedMultiple, this.selectedRange);
        this._focusedDate = (0, utils_1.dateInRange)(this.calculateFocusFromValue && calculatedFocus !== null
            ? calculatedFocus
            : this.state.focusedDate, this.min, this.max);
        var wrapperClassName = (0, kendo_react_common_1.classNames)('k-widget k-calendar k-calendar-range', {
            'k-disabled': this.props.disabled
        }, this.props.className);
        var visualizedRange = this.rangeWithFocused(this.selectedRange, this.focusedDate);
        var prevViewTitle = this.localization.toLanguageString(messages_1.prevView, messages_1.messages[messages_1.prevView]);
        var nextViewTittle = this.localization.toLanguageString(messages_1.nextView, messages_1.messages[messages_1.nextView]);
        var isPrevDisabled = !this.canNavigate(models_1.Action.PrevView);
        var isNextDisabled = !this.canNavigate(models_1.Action.NextView);
        var prevBtnAria = { 'aria-disabled': isPrevDisabled };
        var nextBtnAria = { 'aria-disabled': isNextDisabled };
        var didViewChange = this.lastView !== activeView;
        var isDateInList = this.dates && this.service.isInArray(this.focusedDate, this.dates);
        var didViewsCountChange = this.lastViewsCount !== this.props.views;
        if (!isDateInList || didViewChange || didViewsCountChange) {
            this.dates = this.service.datesList(this.focusedDate, this.props.views || HorizontalViewList_1.HorizontalViewList.defaultProps.views);
        }
        var activeDate = (0, kendo_date_math_1.cloneDate)(this.dates && this.dates[0] ? this.dates[0] : (0, utils_1.getToday)());
        return (React.createElement("div", { ref: function (el) { _this._element = el; }, className: wrapperClassName, id: this.props.id || this.wrapperID, "aria-labelledby": this.props.ariaLabelledBy, "aria-describedby": this.props.ariaDescribedBy, tabIndex: !this.props.disabled ? this.props.tabIndex : undefined, onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseDown: this.handleMouseDown, onClick: this.handleClick, onKeyDown: this.handleKeyDown, "aria-disabled": this.props.disabled },
            React.createElement(Header_1.Header, { key: ".kendo.calendar.header.".concat(activeDate.getTime()), activeView: activeView, currentDate: activeDate, min: this.min, max: this.max, rangeLength: this.props.views, bus: this.bus, service: this.service, headerTitle: this.props.headerTitle, commands: (React.createElement(React.Fragment, null,
                    React.createElement(kendo_react_buttons_1.Button, __assign({ type: "button", className: "k-calendar-nav-prev", icon: "chevron-left", fillMode: "flat", title: prevViewTitle, disabled: isPrevDisabled, onClick: this.handlePrevButtonClick }, prevBtnAria)),
                    React.createElement(TodayCommand_1.TodayCommand, { min: this.min, max: this.max, onClick: this.handleTodayClick, disabled: !this.todayIsInRange }),
                    React.createElement(kendo_react_buttons_1.Button, __assign({ type: "button", className: "k-calendar-nav-next", icon: "chevron-right", fillMode: "flat", title: nextViewTittle, disabled: isNextDisabled, onClick: this.handleNextButtonClick }, nextBtnAria)))) }),
            React.createElement(HorizontalViewList_1.HorizontalViewList, { ref: function (el) { _this.calendarViewList = el; }, dates: this.dates, activeView: activeView, focusedDate: this.focusedDate, min: this.min, max: this.max, bus: this.bus, service: this.service, selectionRange: visualizedRange, value: this.selectedMultiple || this.selectedDate, cellUID: this.cellUID, views: this.props.views, onChange: this.handleDateChange, showWeekNumbers: this.props.weekNumber, onCellEnter: this.handleCellEnter, cell: this.props.cell, weekCell: this.props.weekCell, headerTitle: this.props.headerTitle })));
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.displayName = 'MultiViewCalendar';
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.propTypes = {
        activeRangeEnd: PropTypes.oneOf(['start', 'end']),
        allowReverse: PropTypes.bool,
        bottomView: PropTypes.oneOf(['month', 'year', 'decade', 'century']),
        className: PropTypes.string,
        defaultActiveView: PropTypes.oneOf(['month', 'year', 'decade', 'century']),
        defaultValue: PropTypes.oneOfType([
            (0, utils_1.nullable)(PropTypes.instanceOf(Date)),
            PropTypes.arrayOf(PropTypes.instanceOf(Date)),
            PropTypes.shape({
                start: (0, utils_1.nullable)(PropTypes.instanceOf(Date)),
                end: (0, utils_1.nullable)(PropTypes.instanceOf(Date))
            })
        ]),
        disabled: PropTypes.bool,
        focusedDate: PropTypes.instanceOf(Date),
        id: PropTypes.string,
        ariaLabelledBy: PropTypes.string,
        ariaDescribedBy: PropTypes.string,
        max: PropTypes.instanceOf(Date),
        min: PropTypes.instanceOf(Date),
        mode: PropTypes.oneOf(['single', 'multiple', 'range']),
        onBlur: PropTypes.func,
        onChange: PropTypes.func,
        onFocus: PropTypes.func,
        tabIndex: PropTypes.number,
        topView: PropTypes.oneOf(['month', 'year', 'decade', 'century']),
        value: PropTypes.oneOfType([
            (0, utils_1.nullable)(PropTypes.instanceOf(Date)),
            PropTypes.arrayOf(PropTypes.instanceOf(Date)),
            PropTypes.shape({
                start: (0, utils_1.nullable)(PropTypes.instanceOf(Date).isRequired),
                end: (0, utils_1.nullable)(PropTypes.instanceOf(Date).isRequired)
            })
        ]),
        views: function (props, propName, componentName) {
            var views = props[propName];
            if (views !== undefined && views < 1) {
                return new Error("Invalid prop '".concat(propName, "' supplied to") +
                    "'".concat(componentName, "'. The '").concat(propName, "' property cannot be less than 1'"));
            }
            return null;
        },
        weekNumber: PropTypes.bool
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.defaultProps = {
        disabled: false,
        min: defaults_1.MIN_DATE,
        max: defaults_1.MAX_DATE,
        navigation: true,
        defaultActiveView: 'month',
        defaultValue: null,
        topView: 'century',
        tabIndex: 0,
        bottomView: 'month',
        views: 2,
        allowReverse: false
    };
    return MultiViewCalendarWithoutContext;
}(React.Component));
exports.MultiViewCalendarWithoutContext = MultiViewCalendarWithoutContext;
/**
 * Represents the PropsContext of the `MultiViewCalendar` component.
 * Used for global configuration of all `MultiViewCalendar` instances.
 *
 * For more information, refer to the [DateInputs Props Context]({% slug props-context_dateinputs %}) article.
 */
exports.MultiViewCalendarPropsContext = (0, kendo_react_common_1.createPropsContext)();
/* eslint-disable @typescript-eslint/no-redeclare -- intentionally naming the component the same as the type */
/**
 * Represents the KendoReact MultiViewCalendar Component.
 *
 * Accepts properties of type [MultiViewCalendarProps]({% slug api_dateinputs_multiviewcalendarprops %}).
 * Obtaining the `ref` returns an object of type [MultiViewCalendarHandle]({% slug api_dateinputs_multiviewcalendarhandle %}).
 */
exports.MultiViewCalendar = (0, kendo_react_common_1.withPropsContext)(exports.MultiViewCalendarPropsContext, MultiViewCalendarWithoutContext);
exports.MultiViewCalendar.displayName = 'KendoReactMultiViewCalendar';
(0, kendo_react_intl_1.registerForIntl)(MultiViewCalendarWithoutContext);
(0, kendo_react_intl_1.registerForLocalization)(MultiViewCalendarWithoutContext);

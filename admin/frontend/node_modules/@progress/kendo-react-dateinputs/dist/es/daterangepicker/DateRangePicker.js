var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { Popup } from '@progress/kendo-react-popup';
import { cloneDate } from '@progress/kendo-date-math';
import { guid, classNames, Keys, createPropsContext, withPropsContext } from '@progress/kendo-react-common';
import { provideLocalizationService, registerForLocalization } from '@progress/kendo-react-intl';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from '../package-metadata';
import { DateInput, DateInputWithoutContext } from '../dateinput/DateInput';
import { MultiViewCalendar } from '../calendar/components/MultiViewCalendar';
import { EMPTY_SELECTIONRANGE } from '../calendar/models';
import { MIN_DATE, MAX_DATE } from '../defaults';
import { swapStartEnd, start, end, separator, messages } from '../messages';
import { Button } from '@progress/kendo-react-buttons';
import { nullable } from '../utils';
/** @hidden */
var DateRangePickerWithoutContext = /** @class */ (function (_super) {
    __extends(DateRangePickerWithoutContext, _super);
    function DateRangePickerWithoutContext(props) {
        var _this = _super.call(this, props) || this;
        _this._element = null;
        _this._calendar = null;
        _this._startDateInput = React.createRef();
        _this._endDateInput = React.createRef();
        _this._popupId = guid();
        _this._startInputId = guid();
        _this._endInputId = guid();
        _this.shouldFocusDateInput = false;
        _this.shouldFocusCalendar = false;
        /**
         * @hidden
         */
        _this.focus = function () {
            if (_this.startDateInput) {
                _this.startDateInput.focus();
            }
        };
        _this.setCalendarRef = function (calendar) {
            _this._calendar = calendar;
        };
        _this.focusCalendarElement = function () {
            if (_this._calendar && _this._calendar.element) {
                _this._calendar.element.focus({ preventScroll: true });
            }
        };
        _this.calculateValue = function (props, state) {
            var value = props.value !== undefined
                ? props.value
                : state.value;
            return value || EMPTY_SELECTIONRANGE;
        };
        _this.calculateShow = function (nextProps, nextState) {
            return nextProps.show !== undefined
                ? nextProps.show
                : nextState.show;
        };
        _this.handleReverseClick = function (event) {
            var value = {
                start: _this.value.end,
                end: _this.value.start
            };
            var args = {
                syntheticEvent: event,
                nativeEvent: event.nativeEvent
            };
            _this.handleChange(value, args);
        };
        _this.handleReverseMouseDown = function (event) {
            event.preventDefault();
        };
        _this.handleFocus = function (event) {
            clearTimeout(_this.nextTickId);
            if (!_this.shouldFocusDateInput) {
                _this.setShow(true);
            }
            var onFocus = _this.props.onFocus;
            if (onFocus) {
                onFocus.call(undefined, event);
            }
        };
        _this.handleBlur = function (event) {
            _this.nextTick(function () {
                _this.setShow(false);
            });
            var onBlur = _this.props.onBlur;
            if (onBlur) {
                onBlur.call(undefined, event);
            }
        };
        _this.handleEndChange = function (event) {
            var value = {
                start: _this.value.start,
                end: cloneDate(event.value || undefined)
            };
            _this.handleChange(value, event);
        };
        _this.handleStartChange = function (event) {
            var value = {
                start: cloneDate(event.value || undefined),
                end: _this.value.end
            };
            _this.handleChange(value, event);
        };
        _this.extractRangeFromValue = function (event) {
            if (!Array.isArray(event.value) && !(event.value instanceof Date)) {
                return event.value || EMPTY_SELECTIONRANGE;
            }
            var candidate = Array.isArray(event.value) ? event.value[0] : event.value;
            return {
                start: _this.value.end !== null ? candidate : _this.value.start,
                end: _this.value.start !== null ? candidate : _this.value.end
            };
        };
        _this.handleCalendarChange = function (event) {
            var value = _this.extractRangeFromValue(event);
            _this.handleChange(value, event);
        };
        _this.handleKeyDown = function (event) {
            var keyCode = event.keyCode, altKey = event.altKey;
            if (keyCode === Keys.esc) {
                event.preventDefault();
                _this.shouldFocusDateInput = true;
                _this.setShow(false);
            }
            else if (altKey && keyCode === Keys.down) {
                event.preventDefault();
                _this.shouldFocusCalendar = true;
                _this.setShow(true);
            }
            else if (keyCode === Keys.tab
                && _this.show
                && _this._calendar
                && _this._calendar.element
                && _this.endDateInput
                && _this.endDateInput.element
                && document
                && document.activeElement === _this.endDateInput.element) {
                event.preventDefault();
                _this.focusCalendarElement();
            }
        };
        _this.handleChange = function (value, event) {
            _this.setState({ value: value });
            _this.valueDuringOnChange = value;
            var onChange = _this.props.onChange;
            if (onChange) {
                var args = {
                    syntheticEvent: event.syntheticEvent,
                    nativeEvent: event.nativeEvent,
                    value: _this.value,
                    show: _this.show,
                    target: _this
                };
                onChange.call(undefined, args);
            }
            _this.valueDuringOnChange = undefined;
        };
        validatePackage(packageMetadata);
        _this.state = {
            show: _this.props.show || _this.props.defaultShow || DateRangePickerWithoutContext.defaultProps.defaultShow,
            value: _this.props.value || _this.props.defaultValue || DateRangePickerWithoutContext.defaultProps.defaultValue
        };
        _this.nextTick = _this.nextTick.bind(_this);
        _this.setShow = _this.setShow.bind(_this);
        _this.focusCalendarElement = _this.focusCalendarElement.bind(_this);
        _this.focusDateInputElement = _this.focusDateInputElement.bind(_this);
        return _this;
    }
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "element", {
        /**
         * Gets the wrapping element of the DateRangePicker.
         */
        get: function () {
            return this._element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "startDateInput", {
        /**
         * Gets the start DateInput component inside the DatePicker component.
         */
        get: function () {
            return this._startDateInput.current;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "endDateInput", {
        /**
         * Gets the end DateInput component inside the DatePicker component.
         */
        get: function () {
            return this._endDateInput.current;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "calendar", {
        /**
         * Gets the MultiVieCalendar inside the DateRangePicker.
         */
        get: function () {
            return this._calendar;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "value", {
        /**
         * Gets the value of the DateRangePicker.
         */
        get: function () {
            var value = this.valueDuringOnChange !== undefined
                ? this.valueDuringOnChange
                : this.props.value !== undefined
                    ? this.props.value
                    : this.state.value;
            return value || EMPTY_SELECTIONRANGE;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "show", {
        /**
         * Gets the popup state of the DateRangePicker.
         */
        get: function () {
            return this.showDuringOnChange !== undefined
                ? this.showDuringOnChange
                : this.props.show !== undefined
                    ? this.props.show
                    : this.state.show;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "min", {
        get: function () {
            return this.props.min !== undefined
                ? this.props.min
                : DateRangePickerWithoutContext.defaultProps.min;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DateRangePickerWithoutContext.prototype, "max", {
        get: function () {
            return this.props.max !== undefined
                ? this.props.max
                : DateRangePickerWithoutContext.defaultProps.max;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    DateRangePickerWithoutContext.prototype.componentDidMount = function () {
        if (this.show) {
            // If defaultShow is true during the initial render, the popup is not aligned.
            this.forceUpdate();
        }
    };
    /**
     * @hidden
     */
    DateRangePickerWithoutContext.prototype.componentDidUpdate = function () {
        if (this.shouldFocusCalendar) {
            this.focusCalendarElement();
        }
        if (this.shouldFocusDateInput) {
            this.focusDateInputElement();
        }
        this.shouldFocusCalendar = false;
        this.shouldFocusDateInput = false;
    };
    /**
     * @hidden
     */
    DateRangePickerWithoutContext.prototype.componentWillUnmount = function () {
        clearTimeout(this.nextTickId);
    };
    /**
     * @hidden
     */
    DateRangePickerWithoutContext.prototype.render = function () {
        var _this = this;
        var value = this.value || EMPTY_SELECTIONRANGE;
        var startDateInputId = (this.props.startDateInputSettings || {}).id || this._startInputId;
        var endDateInputId = (this.props.endDateInputSettings || {}).id || this._endInputId;
        var rootClassName = classNames('k-daterangepicker', {
            'k-disabled': this.props.disabled
        }, this.props.className);
        var localizationService = provideLocalizationService(this);
        var startMessage = localizationService.toLanguageString(start, messages[start]);
        var endMessage = localizationService.toLanguageString(end, messages[end]);
        var separatorMessage = localizationService.toLanguageString(separator, messages[separator]);
        var startDateInputProps = __assign(__assign({ label: startMessage, format: this.props.format, min: this.min, max: this.max, id: this._startInputId, disabled: this.props.disabled, valid: this.props.valid, ariaHasPopup: true, ariaExpanded: this.show }, this.props.startDateInputSettings), { value: value.start, onChange: this.handleStartChange });
        var endDateInputProps = __assign(__assign({ label: endMessage, format: this.props.format, min: this.min, max: this.max, id: this._endInputId, disabled: this.props.disabled, valid: this.props.valid, ariaHasPopup: true, ariaExpanded: this.show }, this.props.endDateInputSettings), { value: value.end, onChange: this.handleEndChange });
        var popupProps = __assign(__assign({ animate: this._element !== null, anchor: this._element, id: this._popupId, anchorAlign: {
                horizontal: 'left',
                vertical: 'bottom'
            }, popupAlign: {
                horizontal: 'left',
                vertical: 'top'
            } }, this.props.popupSettings), { show: this.show });
        var calendarProps = __assign(__assign({ min: this.min, max: this.max, allowReverse: this.props.allowReverse, mode: 'range', focusedDate: this.props.focusedDate, disabled: this.props.disabled }, this.props.calendarSettings), { value: value, onChange: this.handleCalendarChange });
        var calendar = this.props.calendar
            ? React.createElement(this.props.calendar, __assign({}, calendarProps))
            : React.createElement(MultiViewCalendar, __assign({}, calendarProps, { ref: this.setCalendarRef }));
        var reverseButton = (React.createElement(Button, __assign({ className: "k-select", fillMode: "flat", title: provideLocalizationService(this)
                .toLanguageString(swapStartEnd, messages[swapStartEnd]), onMouseDown: this.handleReverseMouseDown, onClick: this.handleReverseClick }, {
            'aria-controls': startDateInputId + ' ' + endDateInputId,
            'aria-label': provideLocalizationService(this)
                .toLanguageString(swapStartEnd, messages[swapStartEnd])
        }),
            React.createElement("span", { style: { transform: 'rotate(90deg)' }, className: "k-icon k-i-arrows-swap" })));
        return (React.createElement("span", { ref: function (span) {
                _this._element = span;
            }, className: rootClassName, style: this.props.style, id: this.props.id, "aria-labelledby": this.props.ariaLabelledBy, "aria-describedby": this.props.ariaDescribedBy, tabIndex: this.props.tabIndex, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyDown: this.handleKeyDown },
            this.props.startDateInput
                ? React.createElement(this.props.startDateInput, __assign({}, startDateInputProps))
                : React.createElement(DateInput, __assign({}, startDateInputProps, { ref: this._startDateInput, ariaRole: "combobox", ariaControls: this._popupId })),
            (this.props.allowReverse
                || (this.props.calendarSettings && this.props.calendarSettings.allowReverse))
                && this.props.swapButton
                ? (reverseButton)
                : (separatorMessage),
            this.props.endDateInput
                ? React.createElement(this.props.endDateInput, __assign({}, endDateInputProps))
                : React.createElement(DateInput, __assign({}, endDateInputProps, { ref: this._endDateInput, ariaRole: "combobox", ariaControls: this._popupId })),
            this.props.popup
                ? React.createElement(this.props.popup, __assign({}, popupProps), calendar)
                : React.createElement(Popup, __assign({}, popupProps), calendar)));
    };
    DateRangePickerWithoutContext.prototype.focusDateInputElement = function () {
        if (!document || !this.startDateInput || !this.startDateInput.element
            || !this.endDateInput || !this.endDateInput.element) {
            return;
        }
        if ((this.value.start === null || this.value.end !== null)
            && document.activeElement !== this.endDateInput.element) {
            this.startDateInput.element.focus({ preventScroll: true });
        }
        else if (document.activeElement !== this.startDateInput.element) {
            this.endDateInput.element.focus({ preventScroll: true });
        }
    };
    DateRangePickerWithoutContext.prototype.nextTick = function (f) {
        // XXX: use window.setTimeout due to async focus/blur events in IE, and missing relatedTarget prop.
        // XXX: https://github.com/facebook/react/issues/3751
        // Handles multiple focus events happening at the same time.
        clearTimeout(this.nextTickId);
        this.nextTickId = window.setTimeout(function () { return f(); });
    };
    DateRangePickerWithoutContext.prototype.setShow = function (show) {
        if (this.show === show) {
            return;
        }
        this.setState({ show: show });
    };
    /**
     * @hidden
     */
    DateRangePickerWithoutContext.displayName = 'DateRangePicker';
    /**
     * @hidden
     */
    DateRangePickerWithoutContext.propTypes = {
        allowReverse: PropTypes.bool,
        calendarSettings: PropTypes.any,
        className: PropTypes.string,
        defaultShow: PropTypes.bool,
        defaultValue: PropTypes.shape({
            start: nullable(PropTypes.instanceOf(Date).isRequired),
            end: nullable(PropTypes.instanceOf(Date).isRequired)
        }),
        disabled: PropTypes.bool,
        endDateInputSettings: PropTypes.shape(DateInputWithoutContext.propTypes),
        focusedDate: PropTypes.instanceOf(Date),
        format: PropTypes.oneOfType([
            PropTypes.string,
            PropTypes.shape({
                skeleton: PropTypes.string,
                pattern: PropTypes.string,
                date: PropTypes.oneOf(['short', 'medium', 'long', 'full']),
                time: PropTypes.oneOf(['short', 'medium', 'long', 'full']),
                datetime: PropTypes.oneOf(['short', 'medium', 'long', 'full']),
                era: PropTypes.oneOf(['narrow', 'short', 'long']),
                year: PropTypes.oneOf(['numeric', '2-digit']),
                month: PropTypes.oneOf(['numeric', '2-digit', 'narrow', 'short', 'long']),
                day: PropTypes.oneOf(['numeric', '2-digit']),
                weekday: PropTypes.oneOf(['narrow', 'short', 'long']),
                hour: PropTypes.oneOf(['numeric', '2-digit']),
                hour12: PropTypes.bool,
                minute: PropTypes.oneOf(['numeric', '2-digit']),
                second: PropTypes.oneOf(['numeric', '2-digit']),
                timeZoneName: PropTypes.oneOf(['short', 'long'])
            })
        ]),
        id: PropTypes.string,
        ariaLabelledBy: PropTypes.string,
        ariaDescribedBy: PropTypes.string,
        max: PropTypes.instanceOf(Date),
        min: PropTypes.instanceOf(Date),
        onBlur: PropTypes.func,
        onChange: PropTypes.func,
        onFocus: PropTypes.func,
        popupSettings: PropTypes.any,
        show: PropTypes.bool,
        startDateInputSettings: PropTypes.any,
        style: PropTypes.any,
        swapButton: PropTypes.any,
        tabIndex: PropTypes.number,
        value: PropTypes.shape({
            start: nullable(PropTypes.instanceOf(Date).isRequired),
            end: nullable(PropTypes.instanceOf(Date).isRequired)
        })
    };
    /**
     * @hidden
     */
    DateRangePickerWithoutContext.defaultProps = {
        allowReverse: false,
        defaultShow: false,
        defaultValue: EMPTY_SELECTIONRANGE,
        disabled: false,
        format: 'd',
        max: MAX_DATE,
        min: MIN_DATE,
        swapButton: false
    };
    return DateRangePickerWithoutContext;
}(React.Component));
export { DateRangePickerWithoutContext };
/**
 * Represents the PropsContext of the `DateRangePicker` component.
 * Used for global configuration of all `DateRangePicker` instances.
 *
 * For more information, refer to the [DateInputs Props Context]({% slug props-context_dateinputs %}) article.
 */
export var DateRangePickerPropsContext = createPropsContext();
/* eslint-disable @typescript-eslint/no-redeclare */
/**
 * Represents the KendoReact DateRangePicker Component.
 *
 * Accepts properties of type [DateRangePickerProps]({% slug api_dateinputs_daterangepickerprops %}).
 * Obtaining the `ref` returns an object of type [DateRangePickerHandle]({% slug api_dateinputs_daterangepickerhandle %}).
 */
export var DateRangePicker = withPropsContext(DateRangePickerPropsContext, DateRangePickerWithoutContext);
DateRangePicker.displayName = 'KendoReactDateRangePicker';
registerForLocalization(DateRangePickerWithoutContext);

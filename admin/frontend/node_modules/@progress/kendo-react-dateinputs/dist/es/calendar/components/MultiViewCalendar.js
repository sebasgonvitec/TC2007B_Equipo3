var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { registerForIntl, provideIntlService, registerForLocalization, provideLocalizationService } from '@progress/kendo-react-intl';
import { classNames, guid, Keys, createPropsContext, withPropsContext } from '@progress/kendo-react-common';
import { cloneDate, isEqualDate, getDate } from '@progress/kendo-date-math';
import { Button } from '@progress/kendo-react-buttons';
import { Action, CalendarViewEnum, EMPTY_SELECTIONRANGE } from '../models';
import { Header } from './Header';
import { MIN_DATE, MAX_DATE } from '../../defaults';
import { messages, prevView, nextView } from '../../messages';
import { BusViewService, NavigationService } from '../services';
import { dateInRange, isInRange, viewInRange, getToday, nullable } from '../../utils';
import { HorizontalViewList } from './HorizontalViewList';
import { TodayCommand } from './TodayCommand';
var extractDateFromValue = function (min, max, value) {
    if (min === void 0) { min = MultiViewCalendarWithoutContext.defaultProps.min; }
    if (max === void 0) { max = MultiViewCalendarWithoutContext.defaultProps.max; }
    return value instanceof Date && !Array.isArray(value) && isInRange(getDate(value), min, max)
        ? getDate(value)
        : null;
};
var extractMultipleFromValue = function (min, max, value) {
    if (min === void 0) { min = MultiViewCalendarWithoutContext.defaultProps.min; }
    if (max === void 0) { max = MultiViewCalendarWithoutContext.defaultProps.max; }
    return Array.isArray(value)
        ? value.filter(function (date) { return isInRange(date, min, max); }).map(function (date) { return getDate(date); })
        : null;
};
var extractRangeFromValue = function (value) {
    return typeof value === 'object' && !(value instanceof Date) && value !== null && !Array.isArray(value)
        ? value
        : EMPTY_SELECTIONRANGE;
};
var extractFocusedDate = function (single, multiple, range) {
    return single || (multiple && multiple[0]) || (range && range.start);
};
var extractActiveRange = function (range, single) {
    return range.start === null && single === null
        ? 'start'
        : range.end === null
            ? 'end'
            : 'start';
};
/** @hidden */
var MultiViewCalendarWithoutContext = /** @class */ (function (_super) {
    __extends(MultiViewCalendarWithoutContext, _super);
    function MultiViewCalendarWithoutContext(props) {
        var _this = _super.call(this, props) || this;
        _this.dates = [];
        _this.selectedDate = null;
        _this.selectedMultiple = null;
        _this.selectedRange = EMPTY_SELECTIONRANGE;
        _this._focusedDate = new Date();
        _this.cellUID = guid();
        _this.activeRangeEnd = 'start';
        _this._element = null;
        _this.intl = null;
        _this.localization = null;
        _this.service = null;
        _this.wrapperID = guid();
        _this.calendarViewList = null;
        _this.isActive = false;
        _this.calculateFocusFromValue = true;
        /**
         * @hidden
         */
        _this.focus = function () {
            if (_this._element) {
                _this._element.focus();
            }
        };
        _this.clampRange = function (value) { return ({ start: value, end: null }); };
        _this.rangeWithFocused = function (range, focusedDate) {
            return {
                start: range.start,
                end: range.end === null && range.start !== null && _this.isActive ? focusedDate : range.end
            };
        };
        _this.generateRange = function (candidate, value) {
            var end = value.end, start = value.start;
            var shouldSwap = value.start !== null && candidate.getTime() <= value.start.getTime();
            if (!_this.props.allowReverse && shouldSwap) {
                return { start: candidate, end: _this.selectedRange.start };
            }
            return _this.activeRange !== 'end'
                ? ({ start: candidate, end: end })
                : ({ start: start || _this.selectedDate, end: candidate });
        };
        _this.canNavigate = function (action) {
            if (!_this.service) {
                return false;
            }
            var candidate = _this.service.move(_this.focusedDate, action);
            return (_this.min <= candidate && candidate <= _this.max)
                || _this.service.isInSameView(candidate, _this.min)
                || _this.service.isInSameView(candidate, _this.max);
        };
        _this.isListInRange = function (list) {
            return _this.min < list[0]
                && _this.max > list[Math.max(0, (_this.props.views || MultiViewCalendarWithoutContext.defaultProps.views) - 1)];
        };
        _this.navigate = function (action) {
            _this.calculateFocusFromValue = false;
            var candidate = _this.move(action);
            _this.setState({ focusedDate: candidate });
        };
        _this.move = function (action) {
            return _this.clampDate(_this.service.move(_this.focusedDate, action));
        };
        _this.clampDate = function (value) {
            return dateInRange(value, _this.min, _this.max);
        };
        _this.shouldAutoCorrect = function (candidate, value) {
            var end = value.end, start = value.start;
            if (_this.activeRange !== 'end') {
                return end !== null && candidate > end;
            }
            else {
                return start !== null && candidate < start;
            }
        };
        _this.handleCellEnter = function (value) {
            if (_this.props.mode === 'range') {
                _this.calculateFocusFromValue = false;
                _this.setState({
                    focusedDate: value
                });
            }
        };
        _this.handleMouseDown = function (event) {
            event.preventDefault();
        };
        _this.handleClick = function (_) {
            if (!_this._element) {
                return;
            }
            _this._element.focus({ preventScroll: true });
        };
        _this.handleFocus = function (event) {
            _this.isActive = true;
            if (!_this.calendarViewList) {
                return;
            }
            _this.calendarViewList.focusActiveDate();
            var onFocus = _this.props.onFocus;
            if (onFocus) {
                onFocus.call(undefined, event);
            }
        };
        _this.handleBlur = function (event) {
            _this.isActive = false;
            if (!_this.calendarViewList) {
                return;
            }
            _this.calendarViewList.blurActiveDate();
            var onBlur = _this.props.onBlur;
            if (onBlur) {
                onBlur.call(undefined, event);
            }
        };
        _this.handleTodayClick = function (event) {
            if (!_this.todayIsInRange) {
                return;
            }
            _this.handleDateChange(event);
        };
        _this.handlePrevButtonClick = function () {
            _this.navigate(Action.PrevView);
        };
        _this.handleNextButtonClick = function () {
            _this.navigate(Action.NextView);
        };
        _this.handleKeyDown = function (event) {
            var keyCode = event.keyCode;
            if (keyCode === Keys.enter) {
                var args = {
                    syntheticEvent: event,
                    nativeEvent: event.nativeEvent,
                    value: _this.focusedDate,
                    target: _this
                };
                _this.handleDateChange(args);
            }
            else {
                var candidate = dateInRange(_this.navigation.move(_this.focusedDate, _this.navigation.action(event), _this.state.activeView, _this.service, event), _this.min, _this.max);
                if (isEqualDate(_this.focusedDate, candidate)) {
                    return;
                }
                _this.calculateFocusFromValue = false;
                _this.setState({ focusedDate: candidate });
            }
            event.preventDefault();
        };
        _this.handleViewChange = function (_a) {
            var view = _a.view;
            _this.calculateFocusFromValue = false;
            _this.setState({ activeView: view });
        };
        _this.handleDateChange = function (event) {
            var focusedDate = cloneDate(event.value);
            var canNavigateDown = _this.bus.canMoveDown(_this.state.activeView);
            if (_this.props.disabled) {
                return;
            }
            if (canNavigateDown) {
                if (event.isTodayClick) {
                    _this.bus.moveToBottom(_this.state.activeView);
                }
                else {
                    _this.bus.moveDown(_this.state.activeView, event.syntheticEvent);
                    _this.setState({ focusedDate: focusedDate });
                    return;
                }
            }
            _this.calculateFocusFromValue = true;
            var value;
            switch (_this.props.mode) {
                case 'single':
                    value = cloneDate(event.value);
                    break;
                case 'multiple':
                    if (Array.isArray(_this.selectedMultiple)) {
                        var result = _this.selectedMultiple.slice();
                        var index_1 = -1;
                        result.forEach(function (date, idx) {
                            if (isEqualDate(date, event.value)) {
                                index_1 = idx;
                            }
                        });
                        index_1 !== -1
                            ? result.splice(index_1, 1)
                            : result.push(cloneDate(event.value));
                        value = result.slice();
                    }
                    else {
                        if (_this.selectedDate) {
                            value = [cloneDate(_this.selectedDate), cloneDate(event.value)];
                        }
                        else {
                            value = [cloneDate(event.value)];
                        }
                    }
                    break;
                case 'range':
                    var hasSelection = _this.selectedRange.start !== null
                        && _this.selectedRange.end !== null
                        && _this.activeRange === 'start';
                    value = hasSelection
                        ? _this.clampRange(event.value)
                        : _this.generateRange(event.value, _this.selectedRange);
                    _this.activeRangeEnd = _this.activeRange !== 'end' ? 'end' : 'start';
                    break;
                default:
                    value = cloneDate(event.value);
                    break;
            }
            _this.valueDuringOnChange = value;
            _this.setState({ value: value, focusedDate: focusedDate });
            _this.valueDuringOnChange = value;
            var onChange = _this.props.onChange;
            if (onChange) {
                var args = {
                    syntheticEvent: event.syntheticEvent,
                    nativeEvent: event.nativeEvent,
                    value: value,
                    target: _this
                };
                onChange.call(undefined, args);
            }
            _this.valueDuringOnChange = undefined;
        };
        var value = props.value !== undefined
            ? props.value
            : props.defaultValue || MultiViewCalendarWithoutContext.defaultProps.defaultValue;
        var selectedDate = extractDateFromValue(_this.min, _this.max, value);
        var selectedMultiple = extractMultipleFromValue(_this.min, _this.max, value);
        var selectedRange = extractRangeFromValue(value);
        var calculatedFocus = extractFocusedDate(selectedDate, selectedMultiple, selectedRange);
        var activeView = viewInRange(CalendarViewEnum[props.defaultActiveView], _this.bottomView, _this.topView);
        var focusedDate = dateInRange(props.focusedDate || calculatedFocus || getToday(), _this.min, _this.max);
        _this.state = {
            value: value,
            activeView: activeView,
            focusedDate: focusedDate
        };
        _this.activeRangeEnd = extractActiveRange(selectedRange, selectedDate);
        _this.bus = new BusViewService(_this.handleViewChange);
        _this.navigation = new NavigationService(_this.bus);
        _this.calculateFocusFromValue = false;
        _this.lastView = activeView;
        _this.lastViewsCount = _this.props.views || HorizontalViewList.defaultProps.views;
        return _this;
    }
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "element", {
        /**
         * Gets the wrapping element of the MultiViewCalendar component.
         */
        get: function () {
            return this._element;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "value", {
        /**
         * Gets the value of the MultiViewCalendar.
         */
        get: function () {
            return this.valueDuringOnChange !== undefined
                ? this.valueDuringOnChange
                : this.props.value !== undefined
                    ? this.props.value
                    : this.state.value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "focusedDate", {
        /**
         * Gets the current focused date of the MultiViewCalendar.
         */
        get: function () {
            return cloneDate(this._focusedDate);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "min", {
        get: function () {
            return getDate(this.props.min !== undefined
                ? this.props.min
                : MultiViewCalendarWithoutContext.defaultProps.min);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "max", {
        get: function () {
            return getDate(this.props.max !== undefined
                ? this.props.max
                : MultiViewCalendarWithoutContext.defaultProps.max);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "bottomView", {
        get: function () {
            return CalendarViewEnum[this.props.bottomView !== undefined
                ? this.props.bottomView
                : MultiViewCalendarWithoutContext.defaultProps.bottomView];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "topView", {
        get: function () {
            return CalendarViewEnum[this.props.topView !== undefined
                ? this.props.topView
                : MultiViewCalendarWithoutContext.defaultProps.topView];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "activeRange", {
        get: function () {
            return this.props.activeRangeEnd !== undefined
                ? this.props.activeRangeEnd
                : this.activeRangeEnd;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MultiViewCalendarWithoutContext.prototype, "todayIsInRange", {
        get: function () {
            return isInRange(getToday(), getDate(this.min), getDate(this.max));
        },
        enumerable: false,
        configurable: true
    });
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.prototype.componentDidMount = function () {
        this.calculateFocusFromValue = true;
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.prototype.componentDidUpdate = function () {
        if (this.calendarViewList) {
            (this.isActive ? this.calendarViewList.focusActiveDate : this.calendarViewList.blurActiveDate)();
        }
        var stateValue = extractDateFromValue(this.min, this.max, this.value);
        this.calculateFocusFromValue = Boolean(this.selectedDate
            && stateValue
            && (this.selectedDate.getTime() && stateValue.getTime()));
        this.lastView = this.state.activeView;
        this.lastViewsCount = this.props.views || HorizontalViewList.defaultProps.views;
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.prototype.render = function () {
        var _this = this;
        if (this.props._ref) {
            this.props._ref(this);
        }
        this.intl = provideIntlService(this);
        this.localization = provideLocalizationService(this);
        this.bus.configure(this.bottomView, this.topView);
        var activeView = viewInRange(this.state.activeView, this.bottomView, this.topView);
        this.service = this.bus.service(activeView, this.intl);
        this.selectedDate = extractDateFromValue(this.min, this.max, this.value);
        this.selectedMultiple = extractMultipleFromValue(this.min, this.max, this.value);
        this.selectedRange = extractRangeFromValue(this.value);
        var calculatedFocus = extractFocusedDate(this.selectedDate, this.selectedMultiple, this.selectedRange);
        this._focusedDate = dateInRange(this.calculateFocusFromValue && calculatedFocus !== null
            ? calculatedFocus
            : this.state.focusedDate, this.min, this.max);
        var wrapperClassName = classNames('k-widget k-calendar k-calendar-range', {
            'k-disabled': this.props.disabled
        }, this.props.className);
        var visualizedRange = this.rangeWithFocused(this.selectedRange, this.focusedDate);
        var prevViewTitle = this.localization.toLanguageString(prevView, messages[prevView]);
        var nextViewTittle = this.localization.toLanguageString(nextView, messages[nextView]);
        var isPrevDisabled = !this.canNavigate(Action.PrevView);
        var isNextDisabled = !this.canNavigate(Action.NextView);
        var prevBtnAria = { 'aria-disabled': isPrevDisabled };
        var nextBtnAria = { 'aria-disabled': isNextDisabled };
        var didViewChange = this.lastView !== activeView;
        var isDateInList = this.dates && this.service.isInArray(this.focusedDate, this.dates);
        var didViewsCountChange = this.lastViewsCount !== this.props.views;
        if (!isDateInList || didViewChange || didViewsCountChange) {
            this.dates = this.service.datesList(this.focusedDate, this.props.views || HorizontalViewList.defaultProps.views);
        }
        var activeDate = cloneDate(this.dates && this.dates[0] ? this.dates[0] : getToday());
        return (React.createElement("div", { ref: function (el) { _this._element = el; }, className: wrapperClassName, id: this.props.id || this.wrapperID, "aria-labelledby": this.props.ariaLabelledBy, "aria-describedby": this.props.ariaDescribedBy, tabIndex: !this.props.disabled ? this.props.tabIndex : undefined, onFocus: this.handleFocus, onBlur: this.handleBlur, onMouseDown: this.handleMouseDown, onClick: this.handleClick, onKeyDown: this.handleKeyDown, "aria-disabled": this.props.disabled },
            React.createElement(Header, { key: ".kendo.calendar.header.".concat(activeDate.getTime()), activeView: activeView, currentDate: activeDate, min: this.min, max: this.max, rangeLength: this.props.views, bus: this.bus, service: this.service, headerTitle: this.props.headerTitle, commands: (React.createElement(React.Fragment, null,
                    React.createElement(Button, __assign({ type: "button", className: "k-calendar-nav-prev", icon: "chevron-left", fillMode: "flat", title: prevViewTitle, disabled: isPrevDisabled, onClick: this.handlePrevButtonClick }, prevBtnAria)),
                    React.createElement(TodayCommand, { min: this.min, max: this.max, onClick: this.handleTodayClick, disabled: !this.todayIsInRange }),
                    React.createElement(Button, __assign({ type: "button", className: "k-calendar-nav-next", icon: "chevron-right", fillMode: "flat", title: nextViewTittle, disabled: isNextDisabled, onClick: this.handleNextButtonClick }, nextBtnAria)))) }),
            React.createElement(HorizontalViewList, { ref: function (el) { _this.calendarViewList = el; }, dates: this.dates, activeView: activeView, focusedDate: this.focusedDate, min: this.min, max: this.max, bus: this.bus, service: this.service, selectionRange: visualizedRange, value: this.selectedMultiple || this.selectedDate, cellUID: this.cellUID, views: this.props.views, onChange: this.handleDateChange, showWeekNumbers: this.props.weekNumber, onCellEnter: this.handleCellEnter, cell: this.props.cell, weekCell: this.props.weekCell, headerTitle: this.props.headerTitle })));
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.displayName = 'MultiViewCalendar';
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.propTypes = {
        activeRangeEnd: PropTypes.oneOf(['start', 'end']),
        allowReverse: PropTypes.bool,
        bottomView: PropTypes.oneOf(['month', 'year', 'decade', 'century']),
        className: PropTypes.string,
        defaultActiveView: PropTypes.oneOf(['month', 'year', 'decade', 'century']),
        defaultValue: PropTypes.oneOfType([
            nullable(PropTypes.instanceOf(Date)),
            PropTypes.arrayOf(PropTypes.instanceOf(Date)),
            PropTypes.shape({
                start: nullable(PropTypes.instanceOf(Date)),
                end: nullable(PropTypes.instanceOf(Date))
            })
        ]),
        disabled: PropTypes.bool,
        focusedDate: PropTypes.instanceOf(Date),
        id: PropTypes.string,
        ariaLabelledBy: PropTypes.string,
        ariaDescribedBy: PropTypes.string,
        max: PropTypes.instanceOf(Date),
        min: PropTypes.instanceOf(Date),
        mode: PropTypes.oneOf(['single', 'multiple', 'range']),
        onBlur: PropTypes.func,
        onChange: PropTypes.func,
        onFocus: PropTypes.func,
        tabIndex: PropTypes.number,
        topView: PropTypes.oneOf(['month', 'year', 'decade', 'century']),
        value: PropTypes.oneOfType([
            nullable(PropTypes.instanceOf(Date)),
            PropTypes.arrayOf(PropTypes.instanceOf(Date)),
            PropTypes.shape({
                start: nullable(PropTypes.instanceOf(Date).isRequired),
                end: nullable(PropTypes.instanceOf(Date).isRequired)
            })
        ]),
        views: function (props, propName, componentName) {
            var views = props[propName];
            if (views !== undefined && views < 1) {
                return new Error("Invalid prop '".concat(propName, "' supplied to") +
                    "'".concat(componentName, "'. The '").concat(propName, "' property cannot be less than 1'"));
            }
            return null;
        },
        weekNumber: PropTypes.bool
    };
    /**
     * @hidden
     */
    MultiViewCalendarWithoutContext.defaultProps = {
        disabled: false,
        min: MIN_DATE,
        max: MAX_DATE,
        navigation: true,
        defaultActiveView: 'month',
        defaultValue: null,
        topView: 'century',
        tabIndex: 0,
        bottomView: 'month',
        views: 2,
        allowReverse: false
    };
    return MultiViewCalendarWithoutContext;
}(React.Component));
export { MultiViewCalendarWithoutContext };
/**
 * Represents the PropsContext of the `MultiViewCalendar` component.
 * Used for global configuration of all `MultiViewCalendar` instances.
 *
 * For more information, refer to the [DateInputs Props Context]({% slug props-context_dateinputs %}) article.
 */
export var MultiViewCalendarPropsContext = createPropsContext();
/* eslint-disable @typescript-eslint/no-redeclare -- intentionally naming the component the same as the type */
/**
 * Represents the KendoReact MultiViewCalendar Component.
 *
 * Accepts properties of type [MultiViewCalendarProps]({% slug api_dateinputs_multiviewcalendarprops %}).
 * Obtaining the `ref` returns an object of type [MultiViewCalendarHandle]({% slug api_dateinputs_multiviewcalendarhandle %}).
 */
export var MultiViewCalendar = withPropsContext(MultiViewCalendarPropsContext, MultiViewCalendarWithoutContext);
MultiViewCalendar.displayName = 'KendoReactMultiViewCalendar';
registerForIntl(MultiViewCalendarWithoutContext);
registerForLocalization(MultiViewCalendarWithoutContext);

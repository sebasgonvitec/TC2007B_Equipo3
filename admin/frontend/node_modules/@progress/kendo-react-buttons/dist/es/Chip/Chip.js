var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { ChipListSelectionContext, ChipListFocusContext, ChipListDataContext } from './ChipList';
import { classNames, useDir, getTabIndex, Keys, kendoThemeMaps } from '@progress/kendo-react-common';
import { FOCUS_ACTION } from './focus-reducer';
import { DATA_ACTION } from './data-reducer';
import { SELECTION_ACTION } from './selection-reducer';
import { validatePackage } from '@progress/kendo-react-common';
import { packageMetadata } from '../package-metadata';
import { useMouse } from '@progress/kendo-react-common';
/**
 * Represents the Chip component.
 */
export var Chip = React.forwardRef(function (props, ref) {
    var _a;
    validatePackage(packageMetadata);
    var target = React.useRef(null);
    var chipRef = React.useRef(null);
    var dir = useDir(chipRef, props.dir);
    React.useImperativeHandle(target, function () { return ({
        element: chipRef.current,
        props: props
    }); });
    React.useImperativeHandle(ref, function () { return target.current; });
    var _b = React.useContext(ChipListSelectionContext), selection = _b[0], dispatchSelection = _b[1];
    var _c = React.useContext(ChipListFocusContext), focus = _c[0], dispatchFocus = _c[1];
    var _d = React.useContext(ChipListDataContext), dispatchData = _d[1];
    var selected = React.useMemo(function () {
        return (props.selected || (Array.isArray(selection)
            ? selection.some(function (i) { return i === props.value; })
            : selection === props.value));
    }, [props.selected, props.value, selection]);
    var focused = React.useMemo(function () { return focus === props.value; }, [props.value, focus]);
    React.useEffect(function () {
        if (focused && chipRef.current) {
            chipRef.current.focus();
        }
    }, [focused]);
    var handleClick = React.useCallback(function (event) {
        dispatchSelection({ type: SELECTION_ACTION.toggle, payload: props.value, event: event });
    }, [dispatchSelection, props.value]);
    var handleRemove = React.useCallback(function (event) {
        if (!props.removable) {
            return;
        }
        dispatchData({ type: DATA_ACTION.remove, payload: props.value, event: event });
        dispatchFocus({ type: FOCUS_ACTION.reset, payload: props.value, event: event });
        dispatchSelection({ type: SELECTION_ACTION.remove, payload: props.value, event: event });
        if (props.onRemove) {
            props.onRemove.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onRemove, props.value, props.removable, dispatchData, dispatchFocus, dispatchSelection]);
    var handleKeyDown = React.useCallback(function (event) {
        switch (event.keyCode) {
            case Keys.left:
                dispatchFocus({ type: FOCUS_ACTION.prev, payload: props.value, event: event });
                break;
            case Keys.right:
                dispatchFocus({ type: FOCUS_ACTION.next, payload: props.value, event: event });
                break;
            case Keys.enter:
                dispatchSelection({ type: SELECTION_ACTION.toggle, payload: props.value, event: event });
                break;
            case Keys.delete:
                handleRemove(event);
                break;
            default:
                break;
        }
        if (props.onKeyDown) {
            props.onKeyDown.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onKeyDown, props.value, dispatchFocus, dispatchSelection, handleRemove]);
    var handleFocus = React.useCallback(function (event) {
        dispatchFocus({ payload: props.value, type: FOCUS_ACTION.current, event: event });
        if (props.onFocus) {
            props.onFocus.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onFocus, props.value, dispatchFocus]);
    var handleBlur = React.useCallback(function (event) {
        if (props.onBlur) {
            props.onBlur.call(undefined, {
                target: target.current,
                syntheticEvent: event
            });
        }
    }, [props.onBlur]);
    var mouseProps = useMouse(props, target, { onClick: handleClick });
    return (React.createElement("div", __assign({}, mouseProps, { role: props.role, id: props.value, style: props.style, ref: chipRef, dir: dir, tabIndex: getTabIndex(props.tabIndex, props.disabled, undefined), className: classNames('k-chip', (_a = {
                'k-rtl': dir === 'rtl',
                'k-disabled': props.disabled,
                'k-selected': selected,
                'k-focus': focused
            },
            _a["k-chip-".concat(kendoThemeMaps.sizeMap[props.size] || props.size)] = props.size,
            _a["k-rounded-".concat(kendoThemeMaps.roundedMap[props.rounded] || props.rounded)] = props.rounded,
            _a["k-chip-".concat(props.fillMode)] = props.fillMode,
            _a["k-chip-".concat(props.fillMode, "-").concat(props.themeColor)] = Boolean(props.fillMode && props.themeColor),
            _a), props.className), "aria-checked": selected, "aria-disabled": props.disabled, "aria-describedby": props.ariaDescribedBy, onFocus: handleFocus, onBlur: handleBlur, onKeyDown: handleKeyDown }),
        (selected && props.selectedIcon) && React.createElement("span", { className: classNames('k-chip-icon', 'k-icon', props.selectedIcon) }),
        props.icon && React.createElement("span", { className: classNames('k-chip-icon', 'k-icon', props.icon) }),
        React.createElement("span", { className: 'k-chip-content' }, props.children !== undefined
            ? props.children
            : props.text &&
                React.createElement("span", { "aria-label": props.text, className: 'k-chip-label' }, props.text)),
        props.removable && (React.createElement("span", { className: "k-chip-actions" },
            React.createElement("span", { className: classNames('k-chip-action', 'k-chip-remove-action') },
                React.createElement("span", { className: classNames('k-icon', props.removeIcon), onClick: handleRemove }))))));
});
var propTypes = {
    id: PropTypes.string,
    text: PropTypes.string,
    value: PropTypes.any,
    dir: PropTypes.oneOf(['ltr', 'rtl']),
    removable: PropTypes.bool,
    removeIcon: PropTypes.string,
    disabled: PropTypes.bool,
    icon: PropTypes.string,
    selectedIcon: PropTypes.string,
    onRemove: PropTypes.func,
    dataItem: PropTypes.any,
    selected: PropTypes.bool,
    ariaDescribedBy: PropTypes.string,
    size: PropTypes.oneOf([null, 'small', 'medium', 'large']),
    rounded: PropTypes.oneOf([null, 'small', 'medium', 'large', 'full']),
    fillMode: PropTypes.oneOf([null, 'outline', 'solid']),
    // eslint-disable-next-line max-len
    themeColor: PropTypes.oneOf([null, 'base', 'info', 'success', 'warning', 'error'])
};
var defaultProps = {
    disabled: false,
    removable: false,
    removeIcon: 'k-i-x-circle',
    dir: 'ltr',
    size: 'medium',
    rounded: 'medium',
    fillMode: 'solid',
    themeColor: 'base'
};
Chip.displayName = 'KendoReactChip';
// TODO: delete casting when @types/react is updated!
Chip.propTypes = propTypes;
Chip.defaultProps = defaultProps;

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { MultiColumnList } from './../common/MultiColumnList';
import { classNames, getScrollbarWidth, setScrollbarWidth, getter, usePropsContext, createPropsContext } from '@progress/kendo-react-common';
import { ComboBox, ComboBoxWithoutContext } from '../ComboBox/ComboBox';
import { getItemValue } from '../common/utils';
var columnWidth = function (width, defaultWidth) {
    if (width) {
        return typeof width === 'number' ? width + 'px' : width;
    }
    return defaultWidth;
};
/**
 * Represents the PropsContext of the `MultiColumnComboBox` component.
 * Used for global configuration of all `MultiColumnComboBox` instances.
 *
 * For more information, refer to the [Dropdowns Props Context]({% slug props-context_dropdowns %}) article.
 */
export var MultiColumnComboBoxPropsContext = createPropsContext();
/**
 * Represents the MultiColumnComboBox component.
 *
 * Accepts properties of type [MultiColumnComboBoxProps]({% slug api_dropdowns_multicolumncomboboxprops %}).
 * Obtaining the `ref` returns an object of type [MultiColumnComboBoxHandle]({% slug api_dropdowns_multicolumncomboboxhandle %}).
 *
 */
export var MultiColumnComboBox = React.forwardRef(function (directProps, ref) {
    var props = usePropsContext(MultiColumnComboBoxPropsContext, directProps);
    var target = React.useRef(null);
    var comboBoxRef = React.useRef(null);
    var scrollbarWidth = getScrollbarWidth();
    var _a = props.columns, columns = _a === void 0 ? defaultProps.columns : _a, _b = props.popupSettings, popupSettings = _b === void 0 ? defaultProps.popupSettings : _b, className = props.className, size = props.size, onOpen = props.onOpen, onClose = props.onClose, onFocus = props.onFocus, onBlur = props.onBlur, onChange = props.onChange, onFilterChange = props.onFilterChange, onPageChange = props.onPageChange, other = __rest(props, ["columns", "popupSettings", "className", "size", "onOpen", "onClose", "onFocus", "onBlur", "onChange", "onFilterChange", "onPageChange"]);
    React.useImperativeHandle(target, function () {
        return ({
            element: comboBoxRef.current && comboBoxRef.current.element,
            focus: function () {
                if (comboBoxRef.current) {
                    comboBoxRef.current.focus();
                }
            },
            get value() { return comboBoxRef.current && comboBoxRef.current.value; },
            get name() { return comboBoxRef.current && comboBoxRef.current.name; },
            props: props
        });
    });
    React.useImperativeHandle(ref, function () { return target.current; });
    var initialGroupHeader = React.useMemo(function () {
        if (initialGroupHeader === undefined && props.groupField !== undefined && props.data) {
            return getItemValue(props.data[0], props.groupField);
        }
    }, [props.data, props.groupField]);
    var _c = React.useState(initialGroupHeader), groupHeader = _c[0], setGroupHeader = _c[1];
    var header = React.useMemo(function () {
        return (React.createElement(React.Fragment, null,
            props.header,
            React.createElement("div", { className: "k-table-header-wrap" },
                React.createElement("table", { className: "k-table", role: "presentation" },
                    React.createElement("colgroup", null, columns.map(function (column, i) {
                        return (React.createElement("col", { key: column.uniqueKey ? column.uniqueKey : i, style: { width: column.width ? column.width : defaultProps.width } }));
                    })),
                    React.createElement("thead", { className: 'k-table-thead' },
                        React.createElement("tr", { className: 'k-table-row' }, columns.map(function (column, i) {
                            return (React.createElement("th", { className: "k-table-th", key: column.uniqueKey ? column.uniqueKey : i }, column.header || '\u00A0'));
                        })),
                        groupHeader && React.createElement("tr", { className: 'k-table-group-row' },
                            React.createElement("th", { className: 'k-table-th', colSpan: columns.length }, groupHeader)))))));
    }, [props.header, columns, groupHeader]);
    var popupWidth = React.useMemo(function () {
        // These additional 4px are coming from the child elements side borders (fixes horizontal scrollbar)
        return "calc(".concat(columns.map(function (column) { return columnWidth(column.width, defaultProps.width); }).filter(Boolean).join(' + '), " + ").concat(scrollbarWidth, "px + 4px)");
    }, [columns, scrollbarWidth]);
    var skip = props.virtual ? props.virtual.skip : 0;
    var itemRender = React.useCallback(function (li, liProps) {
        var children = columns.map(function (column, i) { return (React.createElement("span", { className: "k-table-td", style: { width: column.width ? column.width : defaultProps.width }, key: column.uniqueKey ? column.uniqueKey : i }, column.field ? getter(column.field)(liProps.dataItem) : '')); });
        var group = undefined;
        var curGroup, prevGroup, groupGetter, data = props.data || [];
        var index = liProps.index - skip;
        if (props.groupField !== undefined) {
            groupGetter = getter(props.groupField);
            curGroup = groupGetter(data[index]);
            prevGroup = groupGetter(data[index - 1]);
            if (curGroup && prevGroup && curGroup !== prevGroup) {
                group = curGroup;
            }
        }
        if (group) {
            children.push(React.createElement("div", { key: "group", className: "k-table-td k-table-group-td" },
                React.createElement("span", null, group)));
        }
        var rendering = React.cloneElement(li, __assign(__assign({}, li.props), { className: classNames('k-table-row', {
                'k-table-alt-row': liProps.index % 2 !== 0,
                'k-focus': liProps.focused,
                'k-selected': liProps.selected,
                'k-first': Boolean(group)
            }) }), children);
        return props.itemRender ? props.itemRender.call(undefined, rendering, liProps) : rendering;
    }, [columns, props.groupField, props.itemRender, props.data, skip]);
    var handleEvent = React.useCallback(function (handler, event) {
        if (handler) {
            handler.call(undefined, __assign(__assign({}, event), { target: target.current }));
        }
    }, []);
    var onOpenHandler = React.useCallback(function (event) { return handleEvent(onOpen, event); }, [onOpen]);
    var onCloseHandler = React.useCallback(function (event) { return handleEvent(onClose, event); }, [onClose]);
    var onFocusHandler = React.useCallback(function (event) { return handleEvent(onFocus, event); }, [onFocus]);
    var onBlurHandler = React.useCallback(function (event) { return handleEvent(onBlur, event); }, [onBlur]);
    var onChangeHandler = React.useCallback(function (event) { return handleEvent(onChange, event); }, [onChange]);
    var onFilterChangeHandler = React.useCallback(function (event) { return handleEvent(onFilterChange, event); }, [onFilterChange]);
    var onPageChangeHandler = React.useCallback(function (event) { return handleEvent(onPageChange, event); }, [onPageChange]);
    var onGroupScroll = React.useCallback(function (event) {
        setGroupHeader(event.group);
    }, []);
    React.useEffect(function () { setScrollbarWidth(); });
    var List = React.useCallback(function (listProps) { return React.createElement(MultiColumnList, __assign({}, listProps)); }, []);
    return (React.createElement(ComboBox, __assign({}, other, { list: List, popupSettings: __assign(__assign({ width: popupWidth }, popupSettings), { popupClass: 'k-dropdowngrid-popup k-reset', className: popupSettings.className }), ref: comboBoxRef, header: header, itemRender: itemRender, size: props.size, rounded: props.rounded, fillMode: props.fillMode, onOpen: onOpenHandler, onClose: onCloseHandler, onFocus: onFocusHandler, onBlur: onBlurHandler, onChange: onChangeHandler, onFilterChange: onFilterChangeHandler, onPageChange: onPageChangeHandler, onGroupScroll: onGroupScroll, className: classNames('k-dropdowngrid', className) })));
});
var propTypes = __assign(__assign({}, ComboBoxWithoutContext.propTypes), { columns: PropTypes.any.isRequired });
var defaultProps = {
    columns: [],
    popupSettings: {},
    width: '200px',
    size: 'medium',
    rounded: 'medium',
    fillMode: 'solid'
};
MultiColumnComboBox.displayName = 'KendoMultiColumnComboBox';
// TODO: delete casting when @types/react is updated!
MultiColumnComboBox.propTypes = propTypes;
MultiColumnComboBox.defaultProps = defaultProps;

var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { getter } from '@progress/kendo-react-common';
/** @hidden */
export var getValueMap = function (value, idGetter) {
    var map = {};
    if (value && value.length) {
        value.forEach(function (item) {
            map[idGetter(item)] = true;
        });
    }
    return map;
};
/**
 * Get MultiSelectTree new value from the component `onChange` event.
 *
 * @param {any[]} data
 * @param {object} options
 * @returns {any[]}
 */
export var getMultiSelectTreeValue = function (data, options) {
    var items = options.items, dataItemKey = options.dataItemKey, value = options.value, _a = options.subItemsField, subItemsField = _a === void 0 ? 'items' : _a, operation = options.operation;
    var idGetter = getter(dataItemKey);
    var valueMap = getValueMap(value, idGetter);
    if (operation === 'clear') {
        return [];
    }
    else if (operation === 'delete') {
        var deletedItemsMap_1 = getValueMap(items, idGetter);
        return value.filter(function (item) { return !deletedItemsMap_1[idGetter(item)]; });
    }
    // operation === 'toggle'
    var selectedItem = items[0];
    var selectedId = idGetter(selectedItem);
    var subItemGetter = getter(subItemsField);
    var stack = __spreadArray([], data, true);
    var context = [];
    var parents = [];
    var foundItem;
    while (stack.length) {
        var currentItem = stack.pop();
        if (selectedId === idGetter(currentItem)) {
            parents = context.map(function (contextItem) { return contextItem.item; });
            foundItem = currentItem;
            break;
        }
        else {
            if (context &&
                context.length &&
                context[context.length - 1].parentPosition === stack.length) {
                context.pop();
            }
            var subItems = subItemGetter(currentItem);
            if (subItems && subItems.length) {
                context.push({ item: currentItem, parentPosition: stack.length });
                stack.push.apply(stack, subItems);
            }
        }
    }
    var childrenStack = __spreadArray([], (subItemGetter(foundItem) || []), true);
    var children = [];
    while (childrenStack.length) {
        var currentItem = childrenStack.pop();
        children.push(currentItem);
        var subItems = subItemGetter(currentItem);
        if (subItems && subItems.length) {
            childrenStack.push.apply(childrenStack, subItems);
        }
    }
    var isChecked = !valueMap[selectedId];
    var newValue = [];
    if (isChecked) {
        newValue.push.apply(newValue, value);
        newValue.push(foundItem);
        newValue.push.apply(newValue, children.filter(function (item) { return !valueMap[idGetter(item)]; }));
        var parentCandidates = parents.filter(function (item) { return !valueMap[idGetter(item)]; });
        var newValueMap_1 = getValueMap(newValue, idGetter);
        for (var i = parentCandidates.length - 1; i > -1; i--) {
            var candidate = parentCandidates[i];
            var subItems = subItemGetter(candidate);
            var checkedChildrenLength = subItems.filter(function (item) { return newValueMap_1[idGetter(item)]; }).length;
            if (checkedChildrenLength < subItems.length) {
                break;
            }
            else {
                newValue.push(candidate);
                newValueMap_1[idGetter(candidate)] = true;
            }
        }
    }
    else {
        var foundId_1 = idGetter(foundItem);
        var childrenMap_1 = getValueMap(children, idGetter);
        var parentsMap_1 = getValueMap(parents, idGetter);
        newValue.push.apply(newValue, (value
            .filter(function (item) {
            var itemId = idGetter(item);
            return !childrenMap_1[itemId] && foundId_1 !== itemId && !parentsMap_1[itemId];
        })));
    }
    return newValue;
};
// /** @hidden */
// const mapCheckAndIntermidiate = (
//     data,
//     options: {
//         valueMap: {[dataItemKey: string]: boolean};
//         callback?: (item: any) => any;
//         idGetter: (item: any) => any;
//         subItemGetter: (item: any) => any;
//         subItemSetter: (item: any, value: any) => void;
//         checkSetter: (item: any, value: any) => void;
//         checkIndeterminateSetter: (item: any, value: any) => void;
//     }
// ) => {
//     const {
//         idGetter,
//         subItemGetter,
//         subItemSetter,
//         checkSetter,
//         checkIndeterminateSetter
//     } = options;
//     if (!data || !data.length) { return [data, false];}
//     let hasChecked = false;
//     const newData = [...data].map(dataItem => {
//         const [children, hasCheckedChildren] = mapCheckAndIntermidiate(subItemGetter(dataItem), options);
//         const isChecked = options.valueMap[idGetter(dataItem)];
//         if (isChecked || hasCheckedChildren) {
//             hasChecked = true;
//         }
//         const newItem = { ...dataItem };
//         subItemSetter(newItem, children);
//         checkSetter(newItem, isChecked);
//         checkIndeterminateSetter(newItem, !isChecked && hasCheckedChildren);
//         return options.callback ? options.callback(newItem) : newItem;
//     });
//     return [newData, hasChecked];
// };
// /**
//  *
//  * @param data
//  * @param options
//  * @returns
//  */
// /**
//  * Creates a new array with the results of calling the provided callback function
//  * on every element in the provided data tree. The new tree items have their `check` and `checkIndeterminate` fields set based on provided value.
//  *
//  * @param {any[]} tree - The data tree.
//  * @param {object} options - The options used to map the tree items like check and checkIndeterminateField fields
//  * @returns {any[]} - The new data tree.
//  */
// export const mapMultiSelectTreeData = (
//     tree,
//     options: {
//         checkField?: string;
//         checkIndeterminateField?: string;
//         subItemsField?: string;
//         dataItemKey: string;
//         value: Array<any>;
//         callback?: (item) => any;
//     }
// ) => {
//     const {
//         subItemsField = 'items',
//         checkField = 'checkField',
//         checkIndeterminateField = 'checkIndeterminateField',
//         callback
//     } = options;
//     const idGetter = getter(options.dataItemKey);
//     const [result] = mapCheckAndIntermidiate(
//         tree,
//         {
//             callback,
//             valueMap: getValueMap(options.value, idGetter),
//             idGetter,
//             subItemGetter: getter(subItemsField),
//             subItemSetter: setter(subItemsField),
//             checkSetter: setter(checkField),
//             checkIndeterminateSetter: setter(checkIndeterminateField)
//         }
//     );
//     return result;
// };

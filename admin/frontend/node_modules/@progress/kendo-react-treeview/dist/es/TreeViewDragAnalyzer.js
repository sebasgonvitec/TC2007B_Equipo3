import { DOM_KENDO_ITEM_ID_FIELD, DOM_KENDO_TREEVIEW_GUID_FIELD } from './utils/consts';
var DROPZONE_BOUNDARY_DELTA = 6;
/**
 * A class which provides an API for analyzing the `drag` events
 * of the TreeView.
 *
 * @example
 * ```jsx
 * class App extends React.Component {
 *     dragClue;
 *     state = { tree };
 *
 *     render() {
 *         return (
 *             <div>
 *                 <TreeView data={this.state.tree} draggable={true}
 *                     onItemDragOver={this.onItemDragOver} onItemDragEnd={this.onItemDragEnd} />
 *                 <TreeViewDragClue ref={dragClue => this.dragClue = dragClue} />
 *             </div>
 *         );
 *     }
 *
 *     onItemDragOver = (event) => {
 *         this.dragClue.show(event.pageY + 10, event.pageX, event.item.text, this.getClueClassName(event));
 *     }
 *     onItemDragEnd = (event) => {
 *         this.dragClue.hide();
 *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();
 *
 *         if (eventAnalyzer.isDropAllowed) {
 *             const updatedTree = moveTreeViewItem(
 *                 event.itemHierarchicalIndex,
 *                 this.state.tree,
 *                 eventAnalyzer.getDropOperation(),
 *                 eventAnalyzer.destinationMeta.itemHierarchicalIndex,
 *             );
 *
 *             this.setState({ tree: updatedTree });
 *         }
 *     }
 *     getClueClassName(event) {
 *         const eventAnalyzer = new TreeViewDragAnalyzer(event).init();
 *         const itemIndex = eventAnalyzer.destinationMeta.itemHierarchicalIndex;
 *
 *         if (eventAnalyzer.isDropAllowed) {
 *             switch (eventAnalyzer.getDropOperation()) {
 *                 case 'child':
 *                     return 'k-i-plus';
 *                 case 'before':
 *                     return itemIndex === '0' || itemIndex.endsWith(`${SEPARATOR}0`) ?
 *                         'k-i-insert-up' : 'k-i-insert-middle';
 *                 case 'after':
 *                     const siblings = getSiblings(itemIndex, this.state.tree);
 *                     const lastIndex = Number(itemIndex.split(SEPARATOR).pop());
 *
 *                     return lastIndex < siblings.length - 1 ? 'k-i-insert-middle' : 'k-i-insert-down';
 *                 default:
 *                     break;
 *             }
 *         }
 *
 *         return 'k-i-cancel';
 *     }
 * }
 *
 * function getSiblings(itemIndex, data) {
 *     let result = data;
 *
 *     const indices = itemIndex.split(SEPARATOR).map(index => Number(index));
 *     for (let i = 0; i < indices.length - 1; i++) {
 *         result = result[indices[i]].items;
 *     }
 *
 *     return result;
 * }
 *
 * const SEPARATOR = '_';
 * const tree = [{
 *     text: 'Furniture', expanded: true, items: [
 *         { text: 'Tables & Chairs', expanded: true },
 *         { text: 'Sofas', expanded: true },
 *         { text: 'Occasional Furniture', expanded: true }]
 * }, {
 *     text: 'Decor', expanded: true, items: [
 *         { text: 'Bed Linen', expanded: true },
 *         { text: 'Curtains & Blinds', expanded: true },
 *         { text: 'Carpets', expanded: true }]
 * }];
 *
 * ReactDOM.render(<App />, document.querySelector('my-app'));
 * ```
 */
var TreeViewDragAnalyzer = /** @class */ (function () {
    /**
     * @param event - The event that will be analyzed.
     */
    function TreeViewDragAnalyzer(event) {
        this.event = event;
        this.initialized = false;
        this.destItemId = '';
        this.destTreeViewGuid = '';
        this.itemId = event.itemHierarchicalIndex;
        this.treeViewGuid = event.target.guid;
    }
    /**
     * The method which initializes the analyzer.
     * Invoke the method before you call any other methods.
     *
     * @returns - The analyzer object of the `drag` event.
     */
    TreeViewDragAnalyzer.prototype.init = function () {
        if (!this.initialized) {
            this.setDestimationMeta(document.elementFromPoint(this.event.clientX, this.event.clientY));
            this.initialized = true;
        }
        return this;
    };
    Object.defineProperty(TreeViewDragAnalyzer.prototype, "isDropAllowed", {
        /**
         * Returns `true` if dropping is allowed. Otherwise, returns `false`.
         */
        get: function () {
            if (this.initialized && this.destItemId && this.destTreeViewGuid) {
                // Disallow circular references.
                return !(("".concat(this.destTreeViewGuid, "_").concat(this.destItemId, "_")).
                    startsWith("".concat(this.treeViewGuid, "_").concat(this.itemId, "_")));
            }
            else {
                return false;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TreeViewDragAnalyzer.prototype, "destinationMeta", {
        /**
         * Returns an object which contains:
         * * The `itemHierarchicalIndex` of the destination item (the item below the dragged item) and
         * * The `guid` of the destination TreeView (the TreeView which renders the destination item).
         */
        get: function () {
            return { itemHierarchicalIndex: this.destItemId, treeViewGuid: this.destTreeViewGuid };
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns the specific drop operation.
     *
     * @returns - The following values are returned:
     * * `before`&mdash;Indicates that the dragged item is positioned at the beginning of the destination item.
     * * `after`&mdash;Indicates that the dragged item is positioned at the end of the destination item.
     * * `child`&mdash;Indicates that the dragged item is positioned in the middle of the destination item.
     * * `undefined`&mdash;Indicates that dropping is not allowed.
     */
    TreeViewDragAnalyzer.prototype.getDropOperation = function () {
        if (this.initialized && this.isDropAllowed) {
            var _a = this.destDomNodeWithMeta.getBoundingClientRect(), top_1 = _a.top, height = _a.height;
            if (top_1 + height - this.event.clientY < DROPZONE_BOUNDARY_DELTA) {
                return 'after';
            }
            else if (this.event.clientY - top_1 < DROPZONE_BOUNDARY_DELTA) {
                return 'before';
            }
            else {
                return 'child';
            }
        }
        else {
            return undefined;
        }
    };
    TreeViewDragAnalyzer.prototype.setDestimationMeta = function (element) {
        var node = element;
        while (node && !node[DOM_KENDO_ITEM_ID_FIELD]) {
            node = node.parentNode;
        }
        if (node && node[DOM_KENDO_ITEM_ID_FIELD]) {
            this.destDomNodeWithMeta = node;
            this.destItemId = node[DOM_KENDO_ITEM_ID_FIELD];
            this.destTreeViewGuid = node[DOM_KENDO_TREEVIEW_GUID_FIELD];
        }
    };
    return TreeViewDragAnalyzer;
}());
export { TreeViewDragAnalyzer };

"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleTreeViewCheckChange = void 0;
var itemUtils_1 = require("./utils/itemUtils");
var itemIdUtils_1 = require("./utils/itemIdUtils");
var misc_1 = require("./utils/misc");
var consts_1 = require("./utils/consts");
/**
 * A helper function which updates the check descriptor.
 *
 * @param event - The event that triggered the change.
 * @param check - The check descriptor that will be updated.
 * @param data - The TreeView items.
 * @param settings - The additional settings that configure the update of the check descriptor.
 * @param childrenField - The field that points to the dataItem sub items. Defaults to `items`.
 * The default behavior allows the selection of multiple items.
 * @returns - The updated copy of the input check descriptor.
 *
 * @example
 * ```jsx
 * class App extends React.Component {
 *    state = { check: [], items: tree };
 *    render() {
 *        return (
 *            <div>
 *                <TreeView
 *                    checkboxes={true} onCheckChange={this.onCheckChange}
 *                    data={processTreeViewItems(this.state.items, { check: this.state.check })}
 *                />
 *                <div style={{ marginTop: 5 }}>
 *                    <i>Press SPACE to check/uncheck the active item</i>
 *                    <div className="example-config">
 *                        Checked Indices: {this.state.check.join(",")}
 *                    </div>
 *                </div>
 *            </div>
 *        );
 *    }
 *    onCheckChange = (event) => {
 *        this.setState({ check: handleTreeViewCheckChange(event, this.state.check, this.state.items) });
 *    }
 * }
 *
 * const tree = [ {
 *    text: 'Furniture', expanded: true, items: [
 *        { text: 'Tables & Chairs' }, { text: 'Sofas' }, { text: 'Occasional Furniture' } ]
 * }, {
 *    text: 'Decor', expanded: true, items: [
 *        { text: 'Bed Linen' }, { text: 'Curtains & Blinds' }, { text: 'Carpets' } ]
 * } ];
 *
 * ReactDOM.render(<App />, document.querySelector('my-app'));
 * ```
 */
function handleTreeViewCheckChange(event, check, data, settings, childrenField) {
    if (settings === void 0) { settings = {}; }
    if (!data || !data.length) {
        return [];
    }
    var _a = parseOperation(check), ids = _a.ids, idField = _a.idField;
    var itemId = idField ? (0, misc_1.getNestedValue)(idField, event.item) : event.itemHierarchicalIndex;
    var idIndex = ids.indexOf(itemId);
    var itemJustChecked = idIndex === -1;
    var subItemsField = childrenField || consts_1.CHILDREN_FIELD;
    var newIds;
    if (settings.singleMode) {
        newIds = itemJustChecked ? [itemId] : [];
    }
    else {
        newIds = ids.slice();
        itemJustChecked ? newIds.push(itemId) : newIds.splice(idIndex, 1);
        if (settings.checkChildren) {
            checkChildren(event.item, event.itemHierarchicalIndex, itemJustChecked, idField, subItemsField, newIds);
        }
        if (settings.checkParents) {
            checkParents(event.itemHierarchicalIndex, itemJustChecked, idField, subItemsField, newIds, data);
        }
    }
    return (0, misc_1.isArray)(check) ? newIds : Object.assign({}, check, { ids: newIds });
}
exports.handleTreeViewCheckChange = handleTreeViewCheckChange;
function parseOperation(operation) {
    var ids;
    var idField = undefined;
    if ((0, misc_1.isArray)(operation)) {
        ids = operation;
    }
    else {
        ids = operation.ids || [];
        idField = operation.idField;
    }
    return { ids: ids, idField: idField };
}
function checkChildren(item, itemHierarchicalIndex, itemJustChecked, idField, childrenField, ids) {
    (0, itemUtils_1.getAllDirectIndirectChildrenIds)(item, itemHierarchicalIndex, childrenField, idField).forEach(function (itemId) {
        if (itemJustChecked && ids.indexOf(itemId) === -1) {
            ids.push(itemId);
        }
        else if (!itemJustChecked && ids.indexOf(itemId) > -1) {
            ids.splice(ids.indexOf(itemId), 1);
        }
    });
}
function checkParents(itemHierarchicalIndex, itemJustChecked, idField, childrenField, ids, data) {
    var it = makeParentsIterator();
    var result = it.next();
    itemJustChecked ? check() : uncheck();
    function check() {
        // Check all parents which have all their children checked.
        while (!result.done) {
            var _a = result.value, id = _a.id, item = _a.item;
            // The first check is needed. However, it is not sure whether to stop the entire loop.
            if (ids.indexOf(id) === -1 &&
                (0, itemUtils_1.areAllDirectChildrenChecked)(item, id, idField, childrenField, ids)) {
                ids.push(id);
                result = it.next();
            }
            else {
                break;
            }
        }
    }
    function uncheck() {
        // Uncheck parents until an already unchecked parent is reached.
        while (!result.done) {
            var id = result.value.id;
            var idIndex = ids.indexOf(id);
            if (idIndex > -1) {
                ids.splice(idIndex, 1);
                result = it.next();
            }
            else {
                break;
            }
        }
    }
    // When called for unchecking, the parent items are not needed.
    // That is why, for optimization, they are not returned.
    function makeParentsIterator() {
        var parents, i, parentId;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!idField) return [3 /*break*/, 5];
                    parents = (0, itemUtils_1.getAllParents)(itemHierarchicalIndex, childrenField, data);
                    i = parents.length - 1;
                    _a.label = 1;
                case 1:
                    if (!(i > -1)) return [3 /*break*/, 4];
                    return [4 /*yield*/, { id: (0, misc_1.getNestedValue)(idField, parents[i]), item: itemJustChecked ? parents[i] : undefined }];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    i--;
                    return [3 /*break*/, 1];
                case 4: return [3 /*break*/, 8];
                case 5:
                    parentId = (0, itemIdUtils_1.getDirectParentId)(itemHierarchicalIndex);
                    _a.label = 6;
                case 6:
                    if (!parentId) return [3 /*break*/, 8];
                    return [4 /*yield*/, { id: parentId, item: itemJustChecked ? (0, itemIdUtils_1.getItemById)(parentId, data, childrenField) : undefined }];
                case 7:
                    _a.sent();
                    parentId = (0, itemIdUtils_1.getDirectParentId)(parentId);
                    return [3 /*break*/, 6];
                case 8: return [2 /*return*/];
            }
        });
    }
}

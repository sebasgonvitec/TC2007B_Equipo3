"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitizeNumber = exports.changeBasedSelection = exports.getDecimalCount = exports.getFirstNumberIndex = exports.getSuffix = exports.getPrefix = exports.getLastNumberIndex = exports.reverseString = exports.getInitialPosition = exports.getFormatSymbols = exports.getFormatPrefixSufix = exports.isDecimalDuplicated = exports.isMinusSymbolRemoved = exports.isMinusSymbolAdded = exports.setInvalid = exports.setSelection = exports.rangeSelection = exports.getMinCursorPosition = exports.getMaxCursorPosition = exports.rangeValue = exports.decreaseValue = exports.increaseValue = exports.toFixedPrecision = exports.limitPrecision = exports.fractionLength = exports.formatValue = exports.getStateOrPropsValue = exports.getInitialState = void 0;
var DEFAULT_NUMBER = 1111111.1111111;
var MAX_DECIMAL = 0.31111111111111117;
var MIN_DECIMAL = 1;
var ONE_NUMBER = 1;
var ZERO_NUMBER = 0;
var DIGITS_REGEX = /\d/;
var MAX_PRECISION = 15;
/**
 * @hidden
 */
var getInitialState = function () { return ({
    eventValue: null,
    prevLooseValue: '',
    currentLooseValue: '',
    focused: false,
    selectionStart: undefined,
    selectionEnd: undefined,
    decimalSelect: false,
    valueIsCorrected: false,
    valueIsOutOfRange: false
}); };
exports.getInitialState = getInitialState;
/**
 * @hidden
 */
var getStateOrPropsValue = function (value, stateValue) {
    return value !== undefined ? value : stateValue;
};
exports.getStateOrPropsValue = getStateOrPropsValue;
/**
 * @hidden
 */
var formatValue = function (value, format, intlService) {
    if (value === null && value === undefined) {
        return '';
    }
    if (typeof value === 'string') {
        return value;
    }
    return intlService.formatNumber(value, format);
};
exports.formatValue = formatValue;
/**
 * @hidden
 */
var fractionLength = function (value) {
    return (String(value).split('.')[1] || '').length;
};
exports.fractionLength = fractionLength;
/**
 * @hidden
 */
var maxFractionLength = function (value1, value2) {
    return Math.max((0, exports.fractionLength)(value1), (0, exports.fractionLength)(value2));
};
/**
 * @hidden
 */
var limitPrecision = function (precision) { return Math.min(precision, MAX_PRECISION); };
exports.limitPrecision = limitPrecision;
/**
 * @hidden
 */
var toFixedPrecision = function (value, precision) {
    var maxPrecision = (0, exports.limitPrecision)(precision);
    return parseFloat(value.toFixed(maxPrecision));
};
exports.toFixedPrecision = toFixedPrecision;
/**
 * @hidden
 */
var increaseValue = function (value, newState, step, min, max, format, intlService) {
    var maxPrecision = maxFractionLength(value || 0, step || 0);
    var increasedValue = (0, exports.rangeValue)((0, exports.toFixedPrecision)((value || 0) + (step || 0), maxPrecision), min, max);
    newState.eventValue = increasedValue;
    newState.currentLooseValue = (0, exports.formatValue)(increasedValue, format, intlService);
    newState.selectionStart = newState.selectionEnd = (0, exports.getLastNumberIndex)(newState.currentLooseValue, DIGITS_REGEX);
};
exports.increaseValue = increaseValue;
/**
 * @hidden
 */
var decreaseValue = function (value, newState, step, min, max, format, intlService) {
    var maxPrecision = maxFractionLength(value || 0, step || 0);
    var decreasedValue = (0, exports.rangeValue)((0, exports.toFixedPrecision)((value || 0) - (step || 0), maxPrecision), min, max);
    newState.eventValue = decreasedValue;
    newState.currentLooseValue = (0, exports.formatValue)(decreasedValue, format, intlService);
    newState.selectionStart = newState.selectionEnd = (0, exports.getLastNumberIndex)(newState.currentLooseValue, DIGITS_REGEX);
};
exports.decreaseValue = decreaseValue;
/**
 * @hidden
 */
var rangeValue = function (value, min, max) {
    if (value == null) {
        return value;
    }
    if (!(value > 1 || value < 1 || value === 1)) {
        // null, undefined or NaN
        return null;
    }
    if (max !== undefined && min !== undefined && max < min) {
        return null;
    }
    if (max !== undefined && value > max) {
        value = max;
    }
    if (min !== undefined && value < min) {
        value = min;
    }
    return value;
};
exports.rangeValue = rangeValue;
/**
 * @hidden
 */
var getMaxCursorPosition = function (nextValue, formatInfo) {
    var formatSuffixIndex = formatInfo.findIndex(function (_a) {
        var _ = _a[0], currSuffix = _a[1];
        return Boolean(currSuffix) && nextValue.indexOf(currSuffix) === nextValue.length - currSuffix.length;
    });
    if (formatSuffixIndex === -1) {
        return -1;
    }
    var suffix = formatInfo[formatSuffixIndex][1];
    return nextValue.length - suffix.length;
};
exports.getMaxCursorPosition = getMaxCursorPosition;
/**
 * @hidden
 */
var getMinCursorPosition = function (nextValue, formatInfo) {
    var formatPrefixIndex = formatInfo.findIndex(function (_a) {
        var currPrefix = _a[0], _ = _a[1];
        return Boolean(currPrefix) && nextValue.indexOf(currPrefix) === 0;
    });
    if (formatPrefixIndex === -1) {
        return -1;
    }
    var prefix = formatInfo[formatPrefixIndex][0];
    return prefix.length;
};
exports.getMinCursorPosition = getMinCursorPosition;
/**
 * @hidden
 */
var rangeSelection = function (nextLooseValue, formatInfo, newState) {
    var maxPosition = (0, exports.getMaxCursorPosition)(nextLooseValue, formatInfo);
    if (maxPosition !== -1 && newState.selectionStart > maxPosition) {
        newState.selectionStart = newState.selectionEnd = maxPosition;
        return;
    }
    if (newState.selectionStart > nextLooseValue.length) {
        newState.selectionStart = newState.selectionEnd = nextLooseValue.length;
    }
    var minPosition = (0, exports.getMinCursorPosition)(nextLooseValue, formatInfo);
    if (minPosition !== -1 && newState.selectionStart < minPosition) {
        newState.selectionStart = newState.selectionEnd = minPosition;
    }
    if (newState.selectionStart === -1) {
        newState.selectionStart = newState.selectionEnd = 0;
    }
};
exports.rangeSelection = rangeSelection;
/**
 * @hidden
 */
var setSelection = function (newState, newIndex, nextLooseValue, formatInfo) {
    newState.selectionStart = newState.selectionEnd = newIndex;
    (0, exports.rangeSelection)(nextLooseValue, formatInfo, newState);
};
exports.setSelection = setSelection;
/**
 * @hidden
 */
var setInvalid = function (newState, format, formatInfo, intlService) {
    newState.eventValue = intlService.parseNumber(newState.prevLooseValue, format);
    newState.currentLooseValue = newState.prevLooseValue;
    newState.valueIsCorrected = true;
    (0, exports.setSelection)(newState, newState.selectionStart, newState.currentLooseValue, formatInfo);
};
exports.setInvalid = setInvalid;
/**
 * @hidden
 */
var isMinusSymbolAdded = function (newState, symbols) {
    var newText = String(newState.currentLooseValue);
    var oldText = String(newState.prevLooseValue);
    return (newText.split(symbols.minusSign).length !== oldText.split(symbols.minusSign).length &&
        newText.length === oldText.length + symbols.minusSign.length);
};
exports.isMinusSymbolAdded = isMinusSymbolAdded;
/**
 * @hidden
 */
var isMinusSymbolRemoved = function (newState, symbols) {
    var newText = String(newState.currentLooseValue);
    var oldText = String(newState.prevLooseValue);
    return (newText.indexOf(symbols.minusSign) === -1 && oldText.indexOf(symbols.minusSign) !== -1);
};
exports.isMinusSymbolRemoved = isMinusSymbolRemoved;
/**
 * @hidden
 */
var isDecimalDuplicated = function (newState, symbols) {
    var newText = String(newState.currentLooseValue);
    return newText.split(symbols.decimal).length > 2;
};
exports.isDecimalDuplicated = isDecimalDuplicated;
/**
 * @hidden
 */
var getFormatPrefixSufix = function (format, intlService) {
    var positiveResult = intlService.formatNumber(DEFAULT_NUMBER, format);
    var negativeResult = intlService.formatNumber(-DEFAULT_NUMBER, format);
    var zeroResult = intlService.formatNumber(ZERO_NUMBER, format);
    var oneResult = intlService.formatNumber(ONE_NUMBER, format);
    var positivePrefix = (0, exports.getPrefix)(positiveResult);
    var negativePrefix = (0, exports.getPrefix)(negativeResult);
    var zeroPrefix = (0, exports.getPrefix)(zeroResult);
    var onePrefix = (0, exports.getPrefix)(oneResult);
    var positiveSuffix = (0, exports.getSuffix)(positiveResult);
    var negativeSuffix = (0, exports.getSuffix)(negativeResult);
    var zeroSuffix = (0, exports.getSuffix)(zeroResult);
    var oneSuffix = (0, exports.getSuffix)(oneResult);
    return {
        positiveInfo: [positivePrefix, positiveSuffix],
        negativeInfo: [negativePrefix, negativeSuffix],
        zeroInfo: [zeroPrefix, zeroSuffix],
        oneInfo: [onePrefix, oneSuffix]
    };
};
exports.getFormatPrefixSufix = getFormatPrefixSufix;
/**
 * @hidden
 */
var getFormatSymbols = function (format, intlService) {
    var positiveResult = intlService.formatNumber(DEFAULT_NUMBER, format);
    var negativeResult = intlService.formatNumber(-DEFAULT_NUMBER, format);
    var zeroResult = intlService.formatNumber(ZERO_NUMBER, format);
    var oneResult = intlService.formatNumber(ONE_NUMBER, format);
    var symbols = intlService.numberSymbols();
    var sanitizeRegex = new RegExp("[\\d\\".concat(symbols.decimal).concat(symbols.group, "]"), 'g');
    var resultWithDuplicates = [positiveResult, negativeResult, zeroResult, oneResult]
        .map(function (result) { return result.replace(sanitizeRegex, ''); })
        .join('');
    return resultWithDuplicates
        .split('')
        .filter(function (x, n, s) { return s.indexOf(x) === n; })
        .join('');
};
exports.getFormatSymbols = getFormatSymbols;
/**
 * @hidden
 */
var getInitialPosition = function (nextLooseValue, symbols) {
    var decimalIdex = nextLooseValue.indexOf(symbols.decimal);
    if (decimalIdex > -1) {
        return decimalIdex;
    }
    return (0, exports.getLastNumberIndex)(nextLooseValue, DIGITS_REGEX);
};
exports.getInitialPosition = getInitialPosition;
/**
 * @hidden
 */
var reverseString = function (str) {
    return str.split('').reverse().join('');
};
exports.reverseString = reverseString;
/**
 * @hidden
 */
var getLastNumberIndex = function (currentLooseValue, inputRegex) {
    return currentLooseValue.length - (0, exports.reverseString)(currentLooseValue).search(inputRegex);
};
exports.getLastNumberIndex = getLastNumberIndex;
/**
 * @hidden
 */
var getPrefix = function (str) {
    return str.split(str[str.search(DIGITS_REGEX)])[0];
};
exports.getPrefix = getPrefix;
/**
 * @hidden
 */
var getSuffix = function (str) {
    var reversedString = (0, exports.reverseString)(str);
    return (0, exports.reverseString)(reversedString.split(reversedString[reversedString.search(DIGITS_REGEX)])[0]);
};
exports.getSuffix = getSuffix;
/**
 * @hidden
 */
var getFirstNumberIndex = function (prevLooseValue, inputRegex) {
    return prevLooseValue.search(inputRegex);
};
exports.getFirstNumberIndex = getFirstNumberIndex;
/**
 * @hidden
 */
var getDecimalCount = function (value, decimal) {
    var currentDecimalPlace = value.indexOf(decimal);
    return currentDecimalPlace > -1 ? value.length - currentDecimalPlace - 1 : 0;
};
exports.getDecimalCount = getDecimalCount;
/**
 * @hidden
 */
var changeBasedSelection = function (currentValue, nextValue, selectionPosition, isDelete, sanitizeRegex) {
    var isCurrentLeadingZero = currentValue.replace(sanitizeRegex, '')[0] === '0';
    var isNextLeadingZero = nextValue.replace(sanitizeRegex, '')[0] === '0';
    if (isCurrentLeadingZero && !isNextLeadingZero) {
        return selectionPosition - 1;
    }
    if (isNextLeadingZero && isDelete) {
        return selectionPosition + 1;
    }
    var numberCounter = 0;
    for (var idx = 0; idx < selectionPosition; idx++) {
        if (DIGITS_REGEX.test(currentValue.charAt(idx))) {
            numberCounter++;
        }
    }
    var newSelection = 0;
    while (numberCounter > 0 && nextValue.length > newSelection) {
        if (DIGITS_REGEX.test(nextValue.charAt(newSelection))) {
            numberCounter--;
        }
        newSelection++;
    }
    return newSelection;
};
exports.changeBasedSelection = changeBasedSelection;
/**
 * @hidden
 */
var sanitizeNumber = function (state, format, intlService) {
    var newState = __assign({}, state);
    var prevLooseValue = newState.prevLooseValue;
    var symbols = intlService.numberSymbols();
    var restrictedSymbols = (0, exports.getFormatSymbols)(format, intlService);
    var currentLooseValueAsString = String(newState.currentLooseValue);
    var prevLooseValueAsString = String(prevLooseValue);
    var sanitizeRegex = new RegExp("[^\\d\\".concat(symbols.decimal, "]"), 'g');
    var sanitizeGroupRegex = new RegExp("[^\\d\\".concat(symbols.decimal, "\\").concat(symbols.group, "]"), 'g');
    var allSymbolsRegex = new RegExp("[\\d\\".concat(symbols.decimal, "\\").concat(symbols.group, "]"));
    var sanitizedString = currentLooseValueAsString.replace(sanitizeRegex, '');
    var numberStart = (0, exports.getFirstNumberIndex)(currentLooseValueAsString, DIGITS_REGEX);
    var numberEnd = numberStart === -1 ? -1 : (0, exports.getLastNumberIndex)(currentLooseValueAsString, DIGITS_REGEX);
    var decimalIndex = currentLooseValueAsString.indexOf(symbols.decimal);
    var sanitizedFormattedString = (currentLooseValueAsString.substring(0, numberStart) +
        currentLooseValueAsString.substring(numberStart, numberEnd).replace(sanitizeGroupRegex, '') +
        currentLooseValueAsString.substring(numberEnd, currentLooseValueAsString.length))
        .split('')
        .filter(function (s) { return restrictedSymbols.indexOf(s) !== -1 || s.search(allSymbolsRegex) !== -1; })
        .join('');
    var formattedMax = intlService.formatNumber(MAX_DECIMAL, format).replace(sanitizeRegex, '');
    var maxDecimalIndex = formattedMax.indexOf(symbols.decimal);
    var maxDecimalCount = maxDecimalIndex > -1 ? formattedMax.length - maxDecimalIndex - 1 : 0;
    var formattedMin = intlService.formatNumber(MIN_DECIMAL, format).replace(sanitizeRegex, '');
    var minDecimalIndex = formattedMin.indexOf(symbols.decimal);
    var minDecimalCount = minDecimalIndex > -1 ? formattedMin.length - minDecimalIndex - 1 : 0;
    var _a = (0, exports.getFormatPrefixSufix)(format, intlService), positiveInfo = _a.positiveInfo, negativeInfo = _a.negativeInfo, zeroInfo = _a.zeroInfo, oneInfo = _a.oneInfo;
    var formatInfo = [positiveInfo, negativeInfo, zeroInfo, oneInfo];
    var isFormatContainPrefixSuffix = formatInfo.findIndex(function (info) { return info.findIndex(function (nestedInfo) { return Boolean(nestedInfo); }) !== -1; }) !== 1;
    var isDelete = currentLooseValueAsString.length > 0 && currentLooseValueAsString.length < prevLooseValueAsString.length;
    var isPercentFormat = typeof format === 'string' &&
        format[0] === 'p' &&
        currentLooseValueAsString &&
        currentLooseValueAsString.indexOf(symbols.percentSign) === -1;
    if (!newState.isPaste) {
        // 1. Empty input
        if (currentLooseValueAsString === '') {
            newState.eventValue = null;
            newState.currentLooseValue = '';
            return newState;
        }
        // 2. Check is minus sign
        if (newState.currentLooseValue === symbols.minusSign && intlService.formatNumber(-0, format) !== prevLooseValueAsString) {
            newState.eventValue = -0;
            newState.currentLooseValue = (0, exports.formatValue)(newState.eventValue, format, intlService);
            (0, exports.setSelection)(newState, (0, exports.getInitialPosition)(newState.currentLooseValue, symbols), newState.currentLooseValue, formatInfo);
            return newState;
        }
        // 3. Minus sign toggle
        if ((0, exports.isMinusSymbolAdded)(newState, symbols)) {
            var nextValue = intlService.parseNumber(prevLooseValue, format);
            newState.eventValue = -(nextValue !== null ? nextValue : 0);
            newState.currentLooseValue = (0, exports.formatValue)(newState.eventValue, format, intlService);
            var currentNumberStart = (0, exports.getFirstNumberIndex)(newState.currentLooseValue, DIGITS_REGEX);
            var oldNumberStart = (0, exports.getFirstNumberIndex)(prevLooseValueAsString, DIGITS_REGEX);
            (0, exports.setSelection)(newState, newState.selectionEnd - 1 + (currentNumberStart - oldNumberStart), newState.currentLooseValue, formatInfo);
            return newState;
        }
        if ((0, exports.isMinusSymbolRemoved)(newState, symbols)) {
            newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
            (0, exports.setSelection)(newState, newState.selectionStart, newState.currentLooseValue, formatInfo);
            return newState;
        }
        // 4. Check is decimal symbol
        if (newState.currentLooseValue === symbols.decimal) {
            newState.eventValue = 0;
            var valueCandidate = (0, exports.formatValue)(newState.eventValue, format, intlService);
            if (minDecimalCount === 0 && maxDecimalCount > 0) {
                var currentLastNumberIndex = (0, exports.getLastNumberIndex)(valueCandidate, DIGITS_REGEX);
                newState.currentLooseValue = valueCandidate.substring(0, currentLastNumberIndex) +
                    symbols.decimal +
                    valueCandidate.substring(currentLastNumberIndex);
            }
            else {
                newState.currentLooseValue = valueCandidate;
            }
            (0, exports.setSelection)(newState, (0, exports.getInitialPosition)(newState.currentLooseValue, symbols) + 1, newState.currentLooseValue, formatInfo);
            return newState;
        }
        // 5. Duplicate decimal - it's possible only as trailing
        if ((0, exports.isDecimalDuplicated)(newState, symbols)) {
            (0, exports.setInvalid)(newState, format, formatInfo, intlService);
            return newState;
        }
        // 6. Percent format
        if (isPercentFormat) {
            newState.eventValue = intlService.parseNumber(currentLooseValueAsString, format) / 100;
            newState.currentLooseValue = (0, exports.formatValue)(newState.eventValue, format, intlService);
            return newState;
        }
        // 7. More than 15 numeric symbols
        var numericSymbols = String(newState.currentLooseValue).replace(/[^\d]/g, '');
        if (numericSymbols.length > MAX_PRECISION) {
            (0, exports.setInvalid)(newState, format, formatInfo, intlService);
            return newState;
        }
        // 8. Check prefix / suffix for modifications
        if (sanitizedString !== currentLooseValueAsString &&
            currentLooseValueAsString &&
            isFormatContainPrefixSuffix) {
            var formatInfoIndex = formatInfo.findIndex(function (_a) {
                var prefix = _a[0], suffix = _a[1];
                var prefixIndex = currentLooseValueAsString.indexOf(prefix);
                var suffixIndex = currentLooseValueAsString.indexOf(suffix);
                var prefixFound = prefixIndex === 0;
                var suffixFound = suffixIndex === currentLooseValueAsString.length - suffix.length;
                var prefixGap = prefixIndex + prefix.length !== numberStart &&
                    numberStart !== -1 &&
                    currentLooseValueAsString[prefixIndex + prefix.length] !== symbols.decimal;
                var suffixGap = suffixIndex !== numberEnd &&
                    numberEnd !== -1 &&
                    currentLooseValueAsString[suffixIndex - 1] !== symbols.decimal;
                if (prefix && suffix) {
                    if (prefixGap || suffixGap) {
                        return false;
                    }
                    return prefixFound && suffixFound;
                }
                if (prefix) {
                    if (prefixGap) {
                        return false;
                    }
                    return prefixFound;
                }
                if (suffix) {
                    if (suffixGap) {
                        return false;
                    }
                    return suffixFound;
                }
                return false;
            });
            if (formatInfoIndex === -1) {
                (0, exports.setInvalid)(newState, format, formatInfo, intlService);
                return newState;
            }
        }
        // 9. Value ending on decimal separator (here as decimal might be typed inside format)
        if (sanitizedString[sanitizedString.length - 1] === symbols.decimal && maxDecimalCount > 0) {
            newState.eventValue = intlService.parseNumber(currentLooseValueAsString, format);
            newState.currentLooseValue = sanitizedFormattedString;
            return newState;
        }
        // 10. prevent deleting decimal and group symbols
        if (newState.currentLooseValue && prevLooseValue) {
            var isSpecialSymbolDeleted = (restrictedSymbols + symbols.decimal + symbols.group)
                .split('')
                .findIndex(function (s) {
                if (currentLooseValueAsString.split('').filter(function (x) { return x === s; }).length <
                    prevLooseValueAsString.split('').filter(function (x) { return x === s; }).length &&
                    currentLooseValueAsString.length + 1 === prevLooseValueAsString.length) {
                    if (s === symbols.decimal &&
                        (0, exports.getDecimalCount)(prevLooseValueAsString.replace(sanitizeRegex, ''), symbols.decimal) === 0) {
                        return false;
                    }
                    return true;
                }
                return false;
            }) > -1;
            if (isSpecialSymbolDeleted) {
                newState.eventValue = intlService.parseNumber(state.prevLooseValue, format);
                newState.currentLooseValue = state.prevLooseValue;
                return newState;
            }
        }
        var currentDecimalCount = (0, exports.getDecimalCount)(sanitizedString, symbols.decimal);
        var endsOnDecimal = sanitizedString[sanitizedString.length - 1] === '0';
        // 11. Deleting more decimals than allowed
        if (isDelete && endsOnDecimal && currentDecimalCount < minDecimalCount) {
            newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
            newState.currentLooseValue = (0, exports.formatValue)(newState.eventValue, format, intlService);
            return newState;
        }
        // 12. Ending on zero OR more decimals than allowed
        if (currentDecimalCount > 0) {
            var valueUntillDecimal = currentLooseValueAsString.substring(0, decimalIndex);
            if (endsOnDecimal && (!valueUntillDecimal || prevLooseValueAsString.indexOf(valueUntillDecimal) !== 0)) {
                // ending on zero but typing before decimal separator
                newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
                var nextLooseValue = (0, exports.formatValue)(newState.eventValue, format, intlService);
                (0, exports.setSelection)(newState, (0, exports.changeBasedSelection)(currentLooseValueAsString, nextLooseValue, newState.selectionEnd, isDelete, sanitizeRegex), nextLooseValue, formatInfo);
                newState.currentLooseValue = nextLooseValue;
                return newState;
            }
            if (currentDecimalCount > maxDecimalCount) {
                // typing more symbols than format allows
                var looseDecimalPlace = currentLooseValueAsString.indexOf(symbols.decimal);
                var result = currentLooseValueAsString.substring(0, looseDecimalPlace) +
                    currentLooseValueAsString.substring(looseDecimalPlace, looseDecimalPlace + 1 + maxDecimalCount) +
                    currentLooseValueAsString.substring(numberEnd, String(newState.currentLooseValue).length);
                newState.eventValue = intlService.parseNumber(result, format);
                newState.currentLooseValue = result;
                (0, exports.setSelection)(newState, newState.selectionStart, result, formatInfo);
                return newState;
            }
            if (minDecimalCount !== maxDecimalCount && currentDecimalCount <= maxDecimalCount && endsOnDecimal) {
                // adding trailing zeroes
                newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
                newState.currentLooseValue = sanitizedFormattedString;
                return newState;
            }
            if (currentDecimalCount < minDecimalCount) {
                // deleting more decimals than allowed
                newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
                newState.currentLooseValue = (0, exports.formatValue)(newState.eventValue, format, intlService);
                return newState;
            }
        }
    }
    // X. All other values should be parsed
    newState.eventValue = intlService.parseNumber(newState.currentLooseValue, format);
    if (isPercentFormat) {
        newState.eventValue = newState.eventValue / 100;
    }
    if (typeof newState.eventValue === 'number') {
        var nextLooseValue = (0, exports.formatValue)(newState.eventValue, format, intlService);
        // First digit add
        if (currentLooseValueAsString.length === 1) {
            (0, exports.setSelection)(newState, (0, exports.getInitialPosition)(nextLooseValue, symbols), nextLooseValue, formatInfo);
        }
        else {
            (0, exports.setSelection)(newState, (0, exports.changeBasedSelection)(currentLooseValueAsString, nextLooseValue, newState.selectionEnd, isDelete, sanitizeRegex), nextLooseValue, formatInfo);
        }
        newState.currentLooseValue = nextLooseValue;
    }
    else {
        // Case when deleting last number
        newState.currentLooseValue = (0, exports.formatValue)(intlService.parseNumber(sanitizedString), format, intlService);
    }
    return newState;
};
exports.sanitizeNumber = sanitizeNumber;

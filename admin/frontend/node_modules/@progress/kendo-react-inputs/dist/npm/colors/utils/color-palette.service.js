"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorPaletteService = void 0;
var misc_1 = require("./misc");
var kendo_drawing_1 = require("@progress/kendo-drawing");
/**
 * @hidden
 */
var ColorPaletteService = /** @class */ (function () {
    function ColorPaletteService() {
        this.colorRows = [];
    }
    ColorPaletteService.prototype.setColorMatrix = function (palette, columns) {
        this.colorRows = [];
        if (!((0, misc_1.isPresent)(palette) && palette.length)) {
            return;
        }
        columns = columns || palette.length;
        for (var start = 0; start < palette.length; start += columns) {
            var row = palette.slice(start, columns + start);
            this.colorRows.push(row);
        }
    };
    ColorPaletteService.prototype.getCellCoordsFor = function (color) {
        var _this = this;
        if (!(0, misc_1.isPresent)(color)) {
            return;
        }
        var parsedColor = color ? (0, kendo_drawing_1.parseColor)(color, true) : color;
        var colors = [color];
        if ((0, misc_1.isPresent)(parsedColor)) {
            colors.push(parsedColor.toCss(), parsedColor.toCssRgba());
        }
        var _loop_1 = function (row) {
            var _loop_2 = function (col) {
                if (colors.some(function (c) { return c === _this.colorRows[row][col]; })) {
                    return { value: { row: row, col: col } };
                }
            };
            for (var col = 0; col < this_1.colorRows[row].length; col++) {
                var state_2 = _loop_2(col);
                if (typeof state_2 === "object")
                    return state_2;
            }
        };
        var this_1 = this;
        for (var row = 0; row < this.colorRows.length; row++) {
            var state_1 = _loop_1(row);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    };
    ColorPaletteService.prototype.getColorAt = function (cellCoords) {
        if (!((0, misc_1.isPresent)(cellCoords) && (0, misc_1.isPresent)(this.colorRows[cellCoords.row]))) {
            return;
        }
        return this.colorRows[cellCoords.row][cellCoords.col];
    };
    ColorPaletteService.prototype.getNextCell = function (current, horizontalStep, verticalStep) {
        if (!((0, misc_1.isPresent)(current) && (0, misc_1.isPresent)(current.row) && (0, misc_1.isPresent)(current.col))) {
            return { row: 0, col: 0 };
        }
        var row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
        var col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
        return { row: row, col: col };
    };
    ColorPaletteService.prototype.clampIndex = function (index, max) {
        var minArrayIndex = 0;
        if (index < minArrayIndex) {
            return minArrayIndex;
        }
        if (index > max) {
            return max;
        }
        return index;
    };
    return ColorPaletteService;
}());
exports.ColorPaletteService = ColorPaletteService;

"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorPicker = exports.ColorPickerPropsContext = void 0;
var React = require("react");
var PropTypes = require("prop-types");
var kendo_react_common_1 = require("@progress/kendo-react-common");
var kendo_react_common_2 = require("@progress/kendo-react-common");
var package_metadata_1 = require("../package-metadata");
var Picker_1 = require("./Picker");
var ColorGradient_1 = require("./ColorGradient");
var ColorPalette_1 = require("./ColorPalette");
var kendo_react_buttons_1 = require("@progress/kendo-react-buttons");
var messages_1 = require("../messages");
var kendo_react_intl_1 = require("@progress/kendo-react-intl");
/**
 * @hidden
 */
var DEFAULT_GRADIENT_SETTINGS = {
    opacity: true
};
/**
 * @hidden
 */
var DEFAULT_PALETTE_SETTINGS = {
    palette: ColorPalette_1.DEFAULT_PRESET,
    tileSize: ColorPalette_1.DEFAULT_TILE_SIZE
};
/**
 * @hidden
 */
var isControlled = function (prop) {
    return prop !== undefined;
};
/**
 * Represents the PropsContext of the `ColorPicker` component.
 * Used for global configuration of all `ColorPicker` instances.
 *
 * For more information, refer to the [Inputs Props Context]({% slug props-context_inputs %}) article.
 */
exports.ColorPickerPropsContext = (0, kendo_react_common_1.createPropsContext)();
/**
 * Represents the [KendoReact ColorPicker component]({% slug overview_colorpicker %}).
 *
 * @example
 * ```jsx
 * class App extends React.Component {
 *     render() {
 *         return <ColorPicker />;
 *     }
 * }
 * ReactDOM.render(<App />, document.querySelector('my-app'));
 * ```
 */
exports.ColorPicker = React.forwardRef(function (directProps, target) {
    var _a, _b;
    (0, kendo_react_common_2.validatePackage)(package_metadata_1.packageMetadata);
    var props = (0, kendo_react_common_1.usePropsContext)(exports.ColorPickerPropsContext, directProps);
    var localization = (0, kendo_react_intl_1.useLocalization)();
    var _c = props.size, size = _c === void 0 ? defaultProps.size : _c, _d = props.rounded, rounded = _d === void 0 ? defaultProps.rounded : _d, _e = props.fillMode, fillMode = _e === void 0 ? defaultProps.fillMode : _e, popupSettings = props.popupSettings, gradientSettings = props.gradientSettings, paletteSettings = props.paletteSettings, valid = props.valid, disabled = props.disabled, tabIndex = props.tabIndex, view = props.view, icon = props.icon, iconClassName = props.iconClassName, onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onActiveColorClick = props.onActiveColorClick;
    var focusableElementRef = React.useRef(null);
    var gradientRef = React.useRef(null);
    var paletteRef = React.useRef(null);
    var blurTimeoutRef = React.useRef();
    var buttonRef = React.useRef(null);
    var focusElement = React.useCallback(function () {
        if (focusableElementRef.current) {
            focusableElementRef.current.focus();
        }
    }, []);
    React.useImperativeHandle(target, function () { return ({
        // we agreed that each element will have focus method exposed
        element: focusableElementRef.current,
        actionElement: buttonRef.current,
        focus: focusElement
    }); });
    var _f = React.useState(false), focused = _f[0], setFocused = _f[1];
    var _g = React.useState(props.defaultValue), stateValue = _g[0], setStateValue = _g[1];
    var _h = React.useState(false), stateOpen = _h[0], setStateOpen = _h[1];
    var isValueControlled = isControlled(props.value);
    var isOpenControlled = isControlled(props.open);
    var value = isValueControlled ? props.value : stateValue;
    var open = isOpenControlled ? props.open : stateOpen;
    var setOpen = React.useCallback(function (nextOpen, isBlur) {
        if (!isOpenControlled) {
            if (!nextOpen && !isBlur && focusableElementRef && focusableElementRef.current) {
                focusableElementRef.current.focus();
            }
            setStateOpen(nextOpen);
        }
    }, [isOpenControlled]);
    var onKeyDownHandler = React.useCallback(function (event) {
        var altKey = event.altKey, keyCode = event.keyCode;
        if (keyCode === kendo_react_common_1.Keys.esc) {
            setOpen(false);
            return;
        }
        if (keyCode === kendo_react_common_1.Keys.enter && !isOpenControlled) {
            event.preventDefault();
            event.stopPropagation();
            setOpen(!open);
            return;
        }
        if (altKey && (keyCode === kendo_react_common_1.Keys.up || keyCode === kendo_react_common_1.Keys.down)) {
            event.preventDefault();
            event.stopPropagation();
            if (keyCode === kendo_react_common_1.Keys.up && focusableElementRef && focusableElementRef.current) {
                focusableElementRef.current.focus();
                setOpen(false);
            }
            if (keyCode === kendo_react_common_1.Keys.down) {
                setOpen(true);
            }
        }
    }, [open, isOpenControlled]);
    var onOpenHandler = React.useCallback(function () {
        // Skip content autofocus when in controlled mode
        if (!isOpenControlled) {
            if (gradientRef.current) {
                gradientRef.current.focus();
            }
            else if (paletteRef.current) {
                paletteRef.current.focus();
            }
        }
    }, [isOpenControlled]);
    var onClickHandler = React.useCallback(function () {
        setOpen(!open, true);
    }, [open]);
    var onActiveColorClickHandler = React.useCallback(function (event) {
        if (onActiveColorClick) {
            onActiveColorClick.call(undefined, {
                syntheticEvent: event,
                nativeEvent: event.nativeEvent,
                value: value
            });
        }
    }, [onActiveColorClick, value]);
    var onFocusHandler = React.useCallback(function (event) {
        if (blurTimeoutRef.current) {
            clearTimeout(blurTimeoutRef.current);
            blurTimeoutRef.current = undefined;
            // case where moving back to input from popup
            // if (event.target === focusableElementRef.current) {
            // setOpen(false); // in this case we should focus input on keydown
            // }
        }
        else {
            setFocused(true);
        }
        if (onFocus) {
            onFocus.call(undefined, {
                nativeEvent: event.nativeEvent,
                syntheticEvent: event
            });
        }
    }, [onFocus]);
    var onBlurTimeout = React.useCallback(function () {
        setOpen(false, true);
        setFocused(false);
        blurTimeoutRef.current = undefined;
    }, []);
    var onBlurHandler = React.useCallback(function (event) {
        clearTimeout(blurTimeoutRef.current);
        blurTimeoutRef.current = window.setTimeout(onBlurTimeout);
        if (onBlur) {
            onBlur.call(undefined, {
                nativeEvent: event.nativeEvent,
                syntheticEvent: event
            });
        }
    }, [onBlur]);
    var onChangeHandler = React.useCallback(function (event, isPalette) {
        var currentValue = isPalette ? event.rgbaValue : event.value;
        if (!isValueControlled) {
            setStateValue(currentValue);
        }
        if (isPalette) {
            setOpen(false);
        }
        if (onChange) {
            onChange.call(undefined, {
                value: currentValue,
                nativeEvent: event.nativeEvent,
                syntheticEvent: event.syntheticEvent
            });
        }
    }, [isValueControlled, onChange]);
    var onPaletteChangeHandler = React.useCallback(function (event) { return onChangeHandler(event, true); }, [isControlled, onChangeHandler]);
    var dir = (0, kendo_react_common_1.useDir)(focusableElementRef, props.dir);
    var isValid = valid !== false;
    return (React.createElement("span", { id: props.id, "aria-labelledby": props.ariaLabelledBy, "aria-describedby": props.ariaDescribedBy, className: (0, kendo_react_common_1.classNames)('k-colorpicker', 'k-picker', 'k-icon-picker', (_a = {},
            _a["k-picker-".concat(kendo_react_common_1.kendoThemeMaps.sizeMap[size] || size)] = size,
            _a["k-picker-".concat(fillMode)] = fillMode,
            _a["k-rounded-".concat(kendo_react_common_1.kendoThemeMaps.roundedMap[rounded] || rounded)] = rounded,
            _a['k-invalid'] = !isValid,
            _a['k-disabled'] = disabled,
            _a['k-focus'] = focused,
            _a)), ref: focusableElementRef, tabIndex: (0, kendo_react_common_1.getTabIndex)(tabIndex, disabled), title: props.title, onKeyDown: onKeyDownHandler, onFocus: onFocusHandler, onBlur: onBlurHandler, dir: dir },
        React.createElement(Picker_1.Picker, { dir: dir, open: open, onOpen: onOpenHandler, popupAnchor: focusableElementRef.current || undefined, popupSettings: __assign({}, popupSettings), input: (React.createElement("span", { onClick: onActiveColorClickHandler, className: 'k-input-inner' },
                React.createElement("span", { className: (0, kendo_react_common_1.classNames)('k-value-icon', 'k-color-preview', {
                        'k-no-color': !value,
                        'k-icon-color-preview': (icon || iconClassName)
                    }) },
                    (iconClassName || icon) && React.createElement("span", { className: (0, kendo_react_common_1.classNames)('k-color-preview-icon', iconClassName, (_b = {},
                            _b["k-icon k-i-".concat(icon)] = (icon && !iconClassName),
                            _b)) }),
                    React.createElement("span", { className: "k-color-preview-mask", style: { backgroundColor: value } })))), button: (React.createElement(kendo_react_buttons_1.Button, { tabIndex: -1, type: "button", onClick: onClickHandler, className: "k-input-button", rounded: null, icon: 'caret-alt-down', "aria-label": localization.toLanguageString(messages_1.colorPickerDropdownButtonAriaLabel, messages_1.messages[messages_1.colorPickerDropdownButtonAriaLabel]) })), content: (React.createElement(React.Fragment, null,
                (view === 'combo' || view === 'gradient') && (React.createElement(ColorGradient_1.ColorGradient, __assign({}, gradientSettings, { tabIndex: 0, ref: gradientRef, value: value, onChange: onChangeHandler }))),
                (view === 'combo' || view === 'palette') && (React.createElement(ColorPalette_1.ColorPalette, __assign({}, paletteSettings, { ref: paletteRef, value: value, onChange: onPaletteChangeHandler }))))) })));
});
exports.ColorPicker.propTypes = {
    value: PropTypes.string,
    defaultValue: PropTypes.string,
    disabled: PropTypes.bool,
    view: PropTypes.oneOf(['gradient', 'palette', 'combo']),
    dir: PropTypes.string,
    id: PropTypes.string,
    ariaLabelledBy: PropTypes.string,
    ariaDescribedBy: PropTypes.string,
    size: PropTypes.oneOf([null, 'small', 'medium', 'large']),
    rounded: PropTypes.oneOf([null, 'small', 'medium', 'large', 'full']),
    fillMode: PropTypes.oneOf([null, 'solid', 'flat', 'outline'])
};
var defaultProps = {
    size: 'medium',
    rounded: 'medium',
    fillMode: 'solid',
    view: 'palette',
    gradientSettings: DEFAULT_GRADIENT_SETTINGS,
    paletteSettings: DEFAULT_PALETTE_SETTINGS
};
exports.ColorPicker.defaultProps = defaultProps;
exports.ColorPicker.displayName = 'KendoColorPicker';

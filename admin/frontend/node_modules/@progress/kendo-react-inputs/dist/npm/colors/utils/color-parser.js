"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContrastFromTwoRGBAs = exports.getContrast = exports.getLuminance = exports.getRGBFromRGBA = exports.getColorFromRGBA = exports.getColorFromHue = exports.getColorFromHSV = exports.getRGBA = exports.getHSV = exports.parseColor = void 0;
var kendo_drawing_1 = require("@progress/kendo-drawing");
var misc_1 = require("./misc");
/**
 * @hidden
 *
 * Returns the hex or RGBA string representation of the color.
 */
var parseColor = function (value, format, safe) {
    if (safe === void 0) { safe = true; }
    var allowedFormats = ['hex', 'rgba']; // TODO: constant?
    // Angular supports third type: name : const allowedFormats: Array<string> = ['hex', 'rgba', 'name'];
    if (allowedFormats.indexOf(format) === -1) {
        throw new Error("Unsupported color output format '".concat(format, "'. The available options are 'hex' or 'rgba'."));
    }
    if (!(0, misc_1.isPresent)(value)) {
        return;
    }
    var parsedColor = (0, kendo_drawing_1.parseColor)(value.trim(), safe);
    if (!(0, misc_1.isPresent)(parsedColor)) {
        return;
    }
    return format === 'hex' ? parsedColor.toCss() : parsedColor.toCssRgba();
};
exports.parseColor = parseColor;
/**
 * @hidden
 *
 * Returns an HSV object representation of the color string.
 */
var getHSV = function (value, safe) {
    if (safe === void 0) { safe = true; }
    var parsed = (0, kendo_drawing_1.parseColor)(value, safe);
    if (!(0, misc_1.isPresent)(parsed)) {
        return {};
    }
    return parsed.toHSV();
};
exports.getHSV = getHSV;
/**
 * @hidden
 *
 * Returns an RGBA object representation of the color string.
 */
var getRGBA = function (value, safe) {
    if (safe === void 0) { safe = true; }
    var parsed = (0, kendo_drawing_1.parseColor)(value, safe);
    if (!(0, misc_1.isPresent)(parsed)) {
        return {};
    }
    return parsed.toBytes();
};
exports.getRGBA = getRGBA;
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
var getColorFromHSV = function (hsva) {
    var hue = (0, misc_1.fitIntoBounds)(hsva.h, 0, 359.9);
    var saturation = (0, misc_1.fitIntoBounds)(hsva.s, 0, 1);
    var value = (0, misc_1.fitIntoBounds)(hsva.v, 0, 1);
    var alpha = (0, misc_1.fitIntoBounds)(hsva.a, 0, 1);
    return kendo_drawing_1.Color.fromHSV(hue, saturation, value, alpha).toCssRgba();
};
exports.getColorFromHSV = getColorFromHSV;
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color based on the `hue` and
 * assuming the `value`, `saturation`, and `alpha` have a value of `1`.
 */
var getColorFromHue = function (hue) {
    return (0, exports.getColorFromHSV)({ h: hue, s: 1, v: 1, a: 1 });
};
exports.getColorFromHue = getColorFromHue;
/**
 * @hidden
 *
 * Returns the RGBA string representation of the color.
 */
var getColorFromRGBA = function (rgba) {
    var red = (0, misc_1.fitIntoBounds)(rgba.r, 0, 255);
    var green = (0, misc_1.fitIntoBounds)(rgba.g, 0, 255);
    var blue = (0, misc_1.fitIntoBounds)(rgba.b, 0, 255);
    var alpha = (0, misc_1.fitIntoBounds)(rgba.a, 0, 1);
    return kendo_drawing_1.Color.fromBytes(red, green, blue, alpha).toCssRgba();
};
exports.getColorFromRGBA = getColorFromRGBA;
/**
 * @hidden
 *
 * Returns the RGB object representation of the color based on the background color.
 */
var getRGBFromRGBA = function (foregroundColor, backgroundColor) {
    var r1 = (0, misc_1.fitIntoBounds)(foregroundColor.r, 0, 255);
    var g1 = (0, misc_1.fitIntoBounds)(foregroundColor.g, 0, 255);
    var b1 = (0, misc_1.fitIntoBounds)(foregroundColor.b, 0, 255);
    var a1 = (0, misc_1.fitIntoBounds)(foregroundColor.a, 0, 1);
    var r2 = (0, misc_1.fitIntoBounds)(backgroundColor.r, 0, 255);
    var g2 = (0, misc_1.fitIntoBounds)(backgroundColor.g, 0, 255);
    var b2 = (0, misc_1.fitIntoBounds)(backgroundColor.b, 0, 255);
    return {
        r: Math.round(((1 - a1) * r2) + (a1 * r1)),
        g: Math.round(((1 - a1) * g2) + (a1 * g1)),
        b: Math.round(((1 - a1) * b2) + (a1 * b1))
    };
};
exports.getRGBFromRGBA = getRGBFromRGBA;
/**
 * @hidden
 *
 * Returns the relative luminance.
 */
var getLuminance = function (rgb) {
    var a = [rgb.r || 0, rgb.g || 0, rgb.b || 0].map(function (v) {
        v /= 255;
        return v <= 0.03928
            ? v / 12.92
            : Math.pow((v + 0.055) / 1.055, 2.4);
    });
    return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
};
exports.getLuminance = getLuminance;
/**
 * @hidden
 *
 * Returns the color contrast.
 */
var getContrast = function (luminance1, luminance2) {
    var brightest = Math.max(luminance1, luminance2);
    var darkest = Math.min(luminance1, luminance2);
    return (brightest + 0.05)
        / (darkest + 0.05);
};
exports.getContrast = getContrast;
/**
 * @hidden
 *
 * Returns the color contrast from two RGBA colors.
 */
var getContrastFromTwoRGBAs = function (a, b) {
    return (0, exports.getContrast)((0, exports.getLuminance)((0, exports.getRGBFromRGBA)(a, b)), (0, exports.getLuminance)((0, exports.getRGBFromRGBA)(b, { r: 0, g: 0, b: 0, a: 1 })));
};
exports.getContrastFromTwoRGBAs = getContrastFromTwoRGBAs;

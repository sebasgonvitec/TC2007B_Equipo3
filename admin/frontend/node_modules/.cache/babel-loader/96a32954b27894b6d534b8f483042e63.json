{"ast":null,"code":"import { Result, ResultType } from './result';\nimport { Stream } from './stream';\n\nvar toArray = function (value) {\n  return (value || '').split('');\n};\n\nvar ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(parse) {\n    this.parse = parse;\n  }\n\n  Parser.prototype.run = function (input, control) {\n    if (control === void 0) {\n      control = '';\n    }\n\n    if (input instanceof Stream) {\n      return this.parse(input);\n    } else {\n      return this.parse(new Stream(toArray(input), toArray(control)));\n    }\n  }; // map :: Functor f => f a ~> (a -> b) -> f b\n\n\n  Parser.prototype.map = function (f) {\n    var _this = this;\n\n    return new Parser(function (stream) {\n      return _this.parse(stream).map(f);\n    });\n  }; // chain :: Chain m => m a ~> (a -> m b) -> m b\n\n\n  Parser.prototype.chain = function (f) {\n    var _this = this;\n\n    return new Parser(function (stream) {\n      return _this.parse(stream).chain(function (v, s) {\n        return f(v).run(s);\n      });\n    });\n  };\n\n  Parser.prototype.isLiteral = function (c) {\n    return this.run(c).type === ResultType.Literal;\n  };\n\n  return Parser;\n}();\n\nexport { Parser };\n/**\n * @hidden\n */\n\nexport var mask = function (args) {\n  return function (rule) {\n    return new Parser(function (stream) {\n      var prompt = args.prompt,\n          promptPlaceholder = args.promptPlaceholder;\n\n      while (!stream.eof()) {\n        var _a = stream.peek(),\n            char = _a.char,\n            control = _a.control;\n\n        if (char === control && control === prompt) {\n          stream.eat();\n          return new Result(prompt, stream, ResultType.Mask);\n        }\n\n        if (rule.test(char)) {\n          stream.eat();\n          return new Result(char, stream, ResultType.Mask);\n        }\n\n        if (char === promptPlaceholder) {\n          stream.eat();\n          return new Result(prompt, stream, ResultType.Mask);\n        }\n\n        stream.eat_input();\n      }\n\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    });\n  };\n};\n/**\n * @hidden\n */\n\nexport var literal = function (_token) {\n  return new Parser(function (stream) {\n    //    let {char, control} = stream.peek();\n    var char = stream.peek().char;\n\n    if (char === _token) {\n      stream.eat();\n      return new Result(_token, stream, ResultType.Literal);\n    } //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n\n\n    return new Result(_token, stream, ResultType.Literal);\n  });\n};\n/**\n * @hidden\n */\n\nexport var unmask = function (prompt) {\n  return function (rule) {\n    return new Parser(function (stream) {\n      while (!stream.eof()) {\n        var _a = stream.peek(),\n            char = _a.char,\n            control = _a.control;\n\n        if (char === prompt && control === prompt) {\n          stream.eat();\n          return new Result(char, stream);\n        }\n\n        if (rule.test(char)) {\n          stream.eat();\n          return new Result(char, stream);\n        }\n\n        stream.eat_input();\n      }\n\n      stream.eat();\n      return new Result('', stream);\n    });\n  };\n};\n/**\n * @hidden\n */\n\nexport var unliteral = function (_token) {\n  return new Parser(function (stream) {\n    if (stream.eof()) {\n      return new Result('', stream);\n    }\n\n    var char = stream.peek().char;\n\n    if (char === _token) {\n      stream.eat();\n    }\n\n    return new Result(_token, stream);\n  });\n};\n/**\n * @hidden\n */\n\nexport var token = function (rules, creator) {\n  return new Parser(function (stream) {\n    var char = stream.next().char;\n    var rule = rules[char];\n\n    if (char === ESCAPE_CHARACTER) {\n      char = stream.next().char;\n      return new Result(creator.literal(char), stream);\n    }\n\n    if (!rule) {\n      return new Result(creator.literal(char), stream);\n    }\n\n    return new Result(creator.mask(rule), stream);\n  });\n};\n/**\n * @hidden\n */\n\nexport var rawMask = function (args) {\n  return new Parser(function (stream) {\n    var prompt = args.prompt,\n        promptPlaceholder = args.promptPlaceholder;\n    var char = stream.next().char;\n\n    if (char === prompt) {\n      return new Result(promptPlaceholder, stream);\n    }\n\n    return new Result(char, stream);\n  });\n};\n/**\n * @hidden\n */\n\nexport var rawLiteral = function (includeLiterals) {\n  return new Parser(function (stream) {\n    var char = stream.next().char;\n\n    if (includeLiterals) {\n      return new Result(char, stream);\n    }\n\n    return new Result('', stream);\n  });\n};","map":{"version":3,"names":["Result","ResultType","Stream","toArray","value","split","ESCAPE_CHARACTER","Parser","parse","prototype","run","input","control","map","f","_this","stream","chain","v","s","isLiteral","c","type","Literal","mask","args","rule","prompt","promptPlaceholder","eof","_a","peek","char","eat","Mask","test","eat_input","literal","_token","unmask","unliteral","token","rules","creator","next","rawMask","rawLiteral","includeLiterals"],"sources":["C:/Users/asana/Documents/TEC/Semestre 5/Seguridad_Informatica/ModuloReact/demo/frontend/node_modules/@progress/kendo-react-inputs/dist/es/maskedtextbox/parsing/parsers.js"],"sourcesContent":["import { Result, ResultType } from './result';\nimport { Stream } from './stream';\nvar toArray = function (value) { return (value || '').split(''); };\nvar ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nvar Parser = /** @class */ (function () {\n    function Parser(parse) {\n        this.parse = parse;\n    }\n    Parser.prototype.run = function (input, control) {\n        if (control === void 0) { control = ''; }\n        if (input instanceof Stream) {\n            return this.parse(input);\n        }\n        else {\n            return this.parse(new Stream(toArray(input), toArray(control)));\n        }\n    };\n    // map :: Functor f => f a ~> (a -> b) -> f b\n    Parser.prototype.map = function (f) {\n        var _this = this;\n        return new Parser(function (stream) { return _this.parse(stream).map(f); });\n    };\n    // chain :: Chain m => m a ~> (a -> m b) -> m b\n    Parser.prototype.chain = function (f) {\n        var _this = this;\n        return new Parser(function (stream) { return _this.parse(stream).chain(function (v, s) { return f(v).run(s); }); });\n    };\n    Parser.prototype.isLiteral = function (c) {\n        return this.run(c).type === ResultType.Literal;\n    };\n    return Parser;\n}());\nexport { Parser };\n/**\n * @hidden\n */\nexport var mask = function (args) { return function (rule) { return new Parser(function (stream) {\n    var prompt = args.prompt, promptPlaceholder = args.promptPlaceholder;\n    while (!stream.eof()) {\n        var _a = stream.peek(), char = _a.char, control = _a.control;\n        if (char === control && control === prompt) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream, ResultType.Mask);\n        }\n        if (char === promptPlaceholder) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result(prompt, stream, ResultType.Mask);\n}); }; };\n/**\n * @hidden\n */\nexport var literal = function (_token) { return new Parser(function (stream) {\n    //    let {char, control} = stream.peek();\n    var char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n        return new Result(_token, stream, ResultType.Literal);\n    }\n    //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n    return new Result(_token, stream, ResultType.Literal);\n}); };\n/**\n * @hidden\n */\nexport var unmask = function (prompt) { return function (rule) { return new Parser(function (stream) {\n    while (!stream.eof()) {\n        var _a = stream.peek(), char = _a.char, control = _a.control;\n        if (char === prompt && control === prompt) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result('', stream);\n}); }; };\n/**\n * @hidden\n */\nexport var unliteral = function (_token) { return new Parser(function (stream) {\n    if (stream.eof()) {\n        return new Result('', stream);\n    }\n    var char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n    }\n    return new Result(_token, stream);\n}); };\n/**\n * @hidden\n */\nexport var token = function (rules, creator) { return new Parser(function (stream) {\n    var char = stream.next().char;\n    var rule = rules[char];\n    if (char === ESCAPE_CHARACTER) {\n        char = stream.next().char;\n        return new Result(creator.literal(char), stream);\n    }\n    if (!rule) {\n        return new Result(creator.literal(char), stream);\n    }\n    return new Result(creator.mask(rule), stream);\n}); };\n/**\n * @hidden\n */\nexport var rawMask = function (args) { return new Parser(function (stream) {\n    var prompt = args.prompt, promptPlaceholder = args.promptPlaceholder;\n    var char = stream.next().char;\n    if (char === prompt) {\n        return new Result(promptPlaceholder, stream);\n    }\n    return new Result(char, stream);\n}); };\n/**\n * @hidden\n */\nexport var rawLiteral = function (includeLiterals) { return new Parser(function (stream) {\n    var char = stream.next().char;\n    if (includeLiterals) {\n        return new Result(char, stream);\n    }\n    return new Result('', stream);\n}); };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
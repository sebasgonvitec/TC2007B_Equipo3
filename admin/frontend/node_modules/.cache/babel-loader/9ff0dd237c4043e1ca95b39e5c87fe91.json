{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\nvar points = [\"anchor\", \"controlIn\", \"controlOut\"];\n\nvar Segment = function (superclass) {\n  function Segment(anchor, controlIn, controlOut) {\n    superclass.call(this);\n    this.anchor(anchor || new Point());\n    this.controlIn(controlIn);\n    this.controlOut(controlOut);\n  }\n\n  if (superclass) Segment.__proto__ = superclass;\n  Segment.prototype = Object.create(superclass && superclass.prototype);\n  Segment.prototype.constructor = Segment;\n\n  Segment.prototype.bboxTo = function bboxTo(toSegment, matrix) {\n    var segmentAnchor = this.anchor().transformCopy(matrix);\n    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n    var rect;\n\n    if (this.controlOut() && toSegment.controlIn()) {\n      rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n    } else {\n      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n    }\n\n    return rect;\n  };\n\n  Segment.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {\n    return Rect.fromPoints(p1, p2);\n  };\n\n  Segment.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {\n    var points = [p1, cp1, cp2, p2];\n\n    var extremesX = this._curveExtremesFor(points, \"x\");\n\n    var extremesY = this._curveExtremesFor(points, \"y\");\n\n    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n    return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n  };\n\n  Segment.prototype._curveExtremesFor = function _curveExtremesFor(points, field) {\n    var extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n\n    return {\n      min: calculateCurveAt(extremes.min, field, points),\n      max: calculateCurveAt(extremes.max, field, points)\n    };\n  };\n\n  Segment.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {\n    var a = x1 - 3 * x2 + 3 * x3 - x4;\n    var b = -2 * (x1 - 2 * x2 + x3);\n    var c = x1 - x2;\n    var sqrt = Math.sqrt(b * b - 4 * a * c);\n    var t1 = 0;\n    var t2 = 1;\n\n    if (a === 0) {\n      if (b !== 0) {\n        t1 = t2 = -c / b;\n      }\n    } else if (!isNaN(sqrt)) {\n      t1 = (-b + sqrt) / (2 * a);\n      t2 = (-b - sqrt) / (2 * a);\n    }\n\n    var min = Math.max(Math.min(t1, t2), 0);\n\n    if (min < 0 || min > 1) {\n      min = 0;\n    }\n\n    var max = Math.min(Math.max(t1, t2), 1);\n\n    if (max > 1 || max < 0) {\n      max = 1;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  };\n\n  Segment.prototype._intersectionsTo = function _intersectionsTo(segment, point) {\n    var intersectionsCount;\n\n    if (this.controlOut() && segment.controlIn()) {\n      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n    } else {\n      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n    }\n\n    return intersectionsCount;\n  };\n\n  Segment.prototype._isOnCurveTo = function _isOnCurveTo(segment, point, width, endSegment) {\n    var bbox = this.bboxTo(segment).expand(width, width);\n\n    if (bbox.containsPoint(point)) {\n      var p1 = this.anchor();\n      var p2 = this.controlOut();\n      var p3 = segment.controlIn();\n      var p4 = segment.anchor();\n\n      if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p1, p2, point);\n      } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p4, p3, point);\n      } //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n\n\n      var points = [p1, p2, p3, p4];\n\n      if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n        return true;\n      }\n\n      var rotation = transform().rotate(45, point);\n      var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n      return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n    }\n  };\n\n  Segment.prototype._isOnLineTo = function _isOnLineTo(segment, point, width) {\n    var p1 = this.anchor();\n    var p2 = segment.anchor();\n    var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n    var rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n    return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n  };\n\n  Segment.prototype._isOnPathTo = function _isOnPathTo(segment, point, width, endSegment) {\n    var isOnPath;\n\n    if (this.controlOut() && segment.controlIn()) {\n      isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n    } else {\n      isOnPath = this._isOnLineTo(segment, point, width);\n    }\n\n    return isOnPath;\n  };\n\n  return Segment;\n}(withPoints(HasObservers, points));\n\nfunction arrayLimits(arr) {\n  var length = arr.length;\n  var min = MAX_NUM;\n  var max = MIN_NUM;\n\n  for (var i = 0; i < length; i++) {\n    max = Math.max(max, arr[i]);\n    min = Math.min(min, arr[i]);\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\n\nexport default Segment;","map":{"version":3,"names":["HasObservers","Rect","Point","transform","deg","MIN_NUM","MAX_NUM","isOutOfEndPoint","calculateCurveAt","hasRootsInRange","curveIntersectionsCount","lineIntersectionsCount","withPoints","points","Segment","superclass","anchor","controlIn","controlOut","call","__proto__","prototype","Object","create","constructor","bboxTo","toSegment","matrix","segmentAnchor","transformCopy","toSegmentAnchor","rect","_curveBoundingBox","_lineBoundingBox","p1","p2","fromPoints","cp1","cp2","extremesX","_curveExtremesFor","extremesY","xLimits","arrayLimits","min","max","x","yLimits","y","field","extremes","_curveExtremes","x1","x2","x3","x4","a","b","c","sqrt","Math","t1","t2","isNaN","_intersectionsTo","segment","point","intersectionsCount","_isOnCurveTo","width","endSegment","bbox","expand","containsPoint","p3","p4","distanceTo","rotation","rotate","rotatedPoints","_isOnLineTo","angle","atan2","_isOnPathTo","isOnPath","arr","length","i"],"sources":["C:/Users/asana/Documents/TEC/Semestre 5/Seguridad_Informatica/ModuloReact/Admin/frontend/node_modules/@progress/kendo-drawing/dist/es/geometry/segment.js"],"sourcesContent":["import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\n\n\nvar points = [ \"anchor\", \"controlIn\", \"controlOut\" ];\n\nvar Segment = (function (superclass) {\n    function Segment(anchor, controlIn, controlOut) {\n        superclass.call(this);\n\n        this.anchor(anchor || new Point());\n        this.controlIn(controlIn);\n        this.controlOut(controlOut);\n    }\n\n    if ( superclass ) Segment.__proto__ = superclass;\n    Segment.prototype = Object.create( superclass && superclass.prototype );\n    Segment.prototype.constructor = Segment;\n\n    Segment.prototype.bboxTo = function bboxTo (toSegment, matrix) {\n        var segmentAnchor = this.anchor().transformCopy(matrix);\n        var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n        var rect;\n\n        if (this.controlOut() && toSegment.controlIn()) {\n            rect = this._curveBoundingBox(\n                segmentAnchor, this.controlOut().transformCopy(matrix),\n                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\n            );\n        } else {\n            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n        }\n\n        return rect;\n    };\n\n    Segment.prototype._lineBoundingBox = function _lineBoundingBox (p1, p2) {\n        return Rect.fromPoints(p1, p2);\n    };\n\n    Segment.prototype._curveBoundingBox = function _curveBoundingBox (p1, cp1, cp2, p2) {\n        var points = [ p1, cp1, cp2, p2 ];\n        var extremesX = this._curveExtremesFor(points, \"x\");\n        var extremesY = this._curveExtremesFor(points, \"y\");\n        var xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\n        var yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\n\n        return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n    };\n\n    Segment.prototype._curveExtremesFor = function _curveExtremesFor (points, field) {\n        var extremes = this._curveExtremes(\n            points[0][field], points[1][field],\n            points[2][field], points[3][field]\n        );\n\n        return {\n            min: calculateCurveAt(extremes.min, field, points),\n            max: calculateCurveAt(extremes.max, field, points)\n        };\n    };\n\n    Segment.prototype._curveExtremes = function _curveExtremes (x1, x2, x3, x4) {\n        var a = x1 - 3 * x2 + 3 * x3 - x4;\n        var b = - 2 * (x1 - 2 * x2 + x3);\n        var c = x1 - x2;\n        var sqrt = Math.sqrt(b * b - 4 * a * c);\n        var t1 = 0;\n        var t2 = 1;\n\n        if (a === 0) {\n            if (b !== 0) {\n                t1 = t2 = -c / b;\n            }\n        } else if (!isNaN(sqrt)) {\n            t1 = (- b + sqrt) / (2 * a);\n            t2 = (- b - sqrt) / (2 * a);\n        }\n\n        var min = Math.max(Math.min(t1, t2), 0);\n        if (min < 0 || min > 1) {\n            min = 0;\n        }\n\n        var max = Math.min(Math.max(t1, t2), 1);\n        if (max > 1 || max < 0) {\n            max = 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    };\n\n    Segment.prototype._intersectionsTo = function _intersectionsTo (segment, point) {\n        var intersectionsCount;\n        if (this.controlOut() && segment.controlIn()) {\n            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\n        } else {\n            intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n        }\n        return intersectionsCount;\n    };\n\n    Segment.prototype._isOnCurveTo = function _isOnCurveTo (segment, point, width, endSegment) {\n        var bbox = this.bboxTo(segment).expand(width, width);\n        if (bbox.containsPoint(point)) {\n            var p1 = this.anchor();\n            var p2 = this.controlOut();\n            var p3 = segment.controlIn();\n            var p4 = segment.anchor();\n\n            if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p1, p2, point);\n            } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p4, p3, point);\n            }\n\n            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n            var points = [ p1, p2, p3, p4 ];\n            if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n                return true;\n            }\n            var rotation = transform().rotate(45, point);\n            var rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\n            return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n        }\n    };\n\n    Segment.prototype._isOnLineTo = function _isOnLineTo (segment, point, width) {\n        var p1 = this.anchor();\n        var p2 = segment.anchor();\n        var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n        var rect = new Rect([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\n        return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n    };\n\n    Segment.prototype._isOnPathTo = function _isOnPathTo (segment, point, width, endSegment) {\n        var isOnPath;\n        if (this.controlOut() && segment.controlIn()) {\n            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n        } else {\n            isOnPath = this._isOnLineTo(segment, point, width);\n        }\n        return isOnPath;\n    };\n\n    return Segment;\n}(withPoints(HasObservers, points)));\n\nfunction arrayLimits(arr) {\n    var length = arr.length;\n    var min = MAX_NUM;\n    var max = MIN_NUM;\n\n    for (var i = 0; i < length; i ++) {\n        max = Math.max(max, arr[i]);\n        min = Math.min(min, arr[i]);\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nexport default Segment;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
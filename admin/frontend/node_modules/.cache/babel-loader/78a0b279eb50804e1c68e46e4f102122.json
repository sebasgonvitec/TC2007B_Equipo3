{"ast":null,"code":"import formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\nvar REMOVAL_PENALTY = 120;\nvar ADDITION_PENALTY = 20;\nvar LENGHT_DELTA = [2, 1, 5, 3, 4];\nvar LONG_LESS_PENALTY_DELTA = -2;\nvar SHORT_LESS_PENALTY_DELTA = -1;\nvar SHORT_MORE_PENALTY_DELTA = 1;\nvar LONG_MORE_PENALTY_DELTA = 2;\nvar PENALTIES = {};\nPENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;\nPENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;\nPENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;\nPENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;\nvar VALUE_FORMAT_LENGTH = {\n  numeric: 1,\n  \"2-digit\": 2,\n  short: 3,\n  long: 4,\n  narrow: 5\n};\nvar TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\n\nfunction getHourSpecifier(options) {\n  return options.hour12 ? \"h\" : \"H\";\n}\n\nvar DATE_OPTIONS_MAP = [{\n  key: \"era\",\n  specifier: \"G\"\n}, {\n  key: \"year\",\n  specifier: \"y\"\n}, {\n  key: \"month\",\n  specifier: \"M\"\n}, {\n  key: \"day\",\n  specifier: \"d\"\n}, {\n  key: \"weekday\",\n  specifier: \"E\"\n}, {\n  key: \"hour\",\n  getSpecifier: getHourSpecifier\n}, {\n  key: \"minute\",\n  specifier: \"m\"\n}, {\n  key: \"second\",\n  specifier: \"s\"\n}, {\n  key: \"timeZoneName\",\n  specifier: \"z\"\n}];\nvar STAND_ALONE_SPECIFIERS = {\n  e: 'c',\n  E: 'c',\n  M: 'L',\n  Q: 'q'\n};\nvar specifiersRegex = {};\nvar resolvedFormats = {};\n\nfunction getSpecifierRegex(specifier) {\n  if (!specifiersRegex[specifier]) {\n    specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n  }\n\n  return specifiersRegex[specifier];\n}\n\nfunction skeletonSpecifiers(skeleton) {\n  var result = [];\n  var current = skeleton.charAt(0);\n  var specifier = current;\n\n  for (var idx = 1; idx < skeleton.length; idx++) {\n    var character = skeleton.charAt(idx);\n\n    if (character === specifier) {\n      current += character;\n    } else {\n      result.push(current);\n      current = specifier = character;\n    }\n  }\n\n  result.push(current);\n  return result;\n}\n\nfunction findBestMatch(specifiers, availableFormats) {\n  var specifiersLength = specifiers.length;\n  var maxScore = -Number.MAX_VALUE;\n  var bestMatches, result;\n\n  for (var format in availableFormats) {\n    var matches = [];\n    var currentFormat = format.replace(\"v\", \"z\");\n    var score = 0;\n\n    for (var idx = 0; idx < specifiersLength; idx++) {\n      var specifier = specifiers[idx];\n      var specifierRegex = getSpecifierRegex(specifier[0]);\n      var match = (specifierRegex.exec(currentFormat) || [])[0];\n\n      if (!match) {\n        score -= REMOVAL_PENALTY;\n      } else {\n        currentFormat = currentFormat.replace(match, EMPTY);\n\n        if (match.length !== specifier.length) {\n          var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n          score -= PENALTIES[delta];\n        }\n      }\n\n      matches.push(match);\n\n      if (score < maxScore) {\n        break;\n      }\n    }\n\n    if (currentFormat.length) {\n      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n    }\n\n    if (score > maxScore) {\n      maxScore = score;\n      bestMatches = matches;\n      result = availableFormats[format];\n    }\n  }\n\n  result = result.replace(\"v\", \"z\");\n\n  for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {\n    var bestMatch = bestMatches[idx$1];\n\n    if (bestMatch && bestMatch !== specifiers[idx$1]) {\n      var matchSpecifier = bestMatches[idx$1][0];\n      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);\n\n      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction cacheFormat(skeleton, format, locale) {\n  if (!resolvedFormats[locale]) {\n    resolvedFormats[locale] = {};\n  }\n\n  resolvedFormats[locale][skeleton] = format;\n}\n\nfunction skeletonFormat(skeleton, info) {\n  var availableFormats = info.calendar.dateTimeFormats.availableFormats;\n\n  if (availableFormats[skeleton]) {\n    return availableFormats[skeleton];\n  }\n\n  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n    return resolvedFormats[info.name][skeleton];\n  }\n\n  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n  var result;\n\n  if (timeStartIndex > 0) {\n    var dateSkeleton = skeleton.substr(0, timeStartIndex);\n    var timeSkeleton = skeleton.substr(timeStartIndex);\n    result = formatString(info.calendar.dateTimeFormats.short, //should be deterimed based on specifiers\n    availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats), availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n  } else {\n    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n  }\n\n  cacheFormat(skeleton, result, info.name);\n  return result;\n}\n\nfunction skeletonFromOptions(options) {\n  var result = [];\n\n  for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n    var option = DATE_OPTIONS_MAP[idx];\n    var field = option.key;\n    var value = options[field];\n\n    if (value) {\n      var spcifier = option.specifier || option.getSpecifier(options);\n      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n    }\n  }\n\n  return result.join(EMPTY);\n}\n\nexport default function datePattern(format, info) {\n  var calendar = info.calendar;\n  var result;\n\n  if (isString(format)) {\n    if (calendar.patterns[format]) {\n      result = calendar.patterns[format];\n    } else {\n      result = format;\n    }\n  } else if (format) {\n    if (format.pattern) {\n      return format.pattern;\n    }\n\n    var skeleton = format.skeleton;\n\n    if (!skeleton) {\n      if (format.datetime) {\n        result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n      } else if (format.date) {\n        result = calendar.dateFormats[format.date];\n      } else if (format.time) {\n        result = calendar.timeFormats[format.time];\n      } else {\n        skeleton = skeletonFromOptions(format);\n      }\n    }\n\n    if (skeleton) {\n      result = skeletonFormat(skeleton, info);\n    }\n  }\n\n  if (!result) {\n    result = calendar.patterns.d;\n  }\n\n  return result;\n}","map":{"version":3,"names":["formatString","isString","EMPTY","REMOVAL_PENALTY","ADDITION_PENALTY","LENGHT_DELTA","LONG_LESS_PENALTY_DELTA","SHORT_LESS_PENALTY_DELTA","SHORT_MORE_PENALTY_DELTA","LONG_MORE_PENALTY_DELTA","PENALTIES","toString","VALUE_FORMAT_LENGTH","numeric","short","long","narrow","TIME_SPECIFIERS_REGEX","getHourSpecifier","options","hour12","DATE_OPTIONS_MAP","key","specifier","getSpecifier","STAND_ALONE_SPECIFIERS","e","E","M","Q","specifiersRegex","resolvedFormats","getSpecifierRegex","RegExp","skeletonSpecifiers","skeleton","result","current","charAt","idx","length","character","push","findBestMatch","specifiers","availableFormats","specifiersLength","maxScore","Number","MAX_VALUE","bestMatches","format","matches","currentFormat","replace","score","specifierRegex","match","exec","delta","Math","max","min","idx$1","bestMatch","matchSpecifier","cacheFormat","locale","skeletonFormat","info","calendar","dateTimeFormats","name","timeStartIndex","search","dateSkeleton","substr","timeSkeleton","skeletonFromOptions","option","field","value","spcifier","repeat","join","datePattern","patterns","pattern","datetime","timeFormats","dateFormats","date","time","d"],"sources":["C:/Users/asana/Documents/TEC/Semestre 5/Seguridad_Informatica/ModuloReact/demo/frontend/node_modules/@progress/kendo-intl/dist/es/dates/date-pattern.js"],"sourcesContent":["import formatString from '../common/format-string';\nimport isString from '../common/is-string';\nimport { EMPTY } from '../common/constants';\n\nvar REMOVAL_PENALTY = 120;\nvar ADDITION_PENALTY = 20;\nvar LENGHT_DELTA = [ 2, 1, 5, 3, 4 ];\nvar LONG_LESS_PENALTY_DELTA = -2;\nvar SHORT_LESS_PENALTY_DELTA = -1;\nvar SHORT_MORE_PENALTY_DELTA = 1;\nvar LONG_MORE_PENALTY_DELTA = 2;\n\nvar PENALTIES = {};\nPENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;\nPENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;\nPENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;\nPENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;\n\nvar VALUE_FORMAT_LENGTH = {\n    numeric: 1,\n    \"2-digit\": 2,\n    short: 3,\n    long: 4,\n    narrow: 5\n};\n\nvar TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;\n\nfunction getHourSpecifier(options) {\n    return options.hour12 ? \"h\" : \"H\";\n}\n\nvar DATE_OPTIONS_MAP = [ {\n    key: \"era\",\n    specifier: \"G\"\n}, {\n    key: \"year\",\n    specifier: \"y\"\n}, {\n    key: \"month\",\n    specifier: \"M\"\n}, {\n    key: \"day\",\n    specifier: \"d\"\n}, {\n    key: \"weekday\",\n    specifier: \"E\"\n}, {\n    key: \"hour\",\n    getSpecifier: getHourSpecifier\n}, {\n    key: \"minute\",\n    specifier: \"m\"\n}, {\n    key: \"second\",\n    specifier: \"s\"\n}, {\n    key: \"timeZoneName\",\n    specifier: \"z\"\n} ];\n\nvar STAND_ALONE_SPECIFIERS = {\n    e: 'c',\n    E: 'c',\n    M: 'L',\n    Q: 'q'\n};\n\nvar specifiersRegex = {};\nvar resolvedFormats = {};\n\nfunction getSpecifierRegex(specifier) {\n    if (!specifiersRegex[specifier]) {\n        specifiersRegex[specifier] = new RegExp(specifier + \"+\");\n    }\n    return specifiersRegex[specifier];\n}\n\nfunction skeletonSpecifiers(skeleton) {\n    var result = [];\n    var current = skeleton.charAt(0);\n    var specifier = current;\n    for (var idx = 1; idx < skeleton.length; idx++) {\n        var character = skeleton.charAt(idx);\n        if (character === specifier) {\n            current += character;\n        } else {\n            result.push(current);\n            current = specifier = character;\n        }\n    }\n\n    result.push(current);\n\n    return result;\n}\n\nfunction findBestMatch(specifiers, availableFormats) {\n    var specifiersLength = specifiers.length;\n    var maxScore = -Number.MAX_VALUE;\n    var bestMatches, result;\n    for (var format in availableFormats) {\n        var matches = [];\n        var currentFormat = format.replace(\"v\", \"z\");\n        var score = 0;\n        for (var idx = 0; idx < specifiersLength; idx++) {\n            var specifier = specifiers[idx];\n            var specifierRegex = getSpecifierRegex(specifier[0]);\n            var match = (specifierRegex.exec(currentFormat) || [])[0];\n\n            if (!match) {\n                score -= REMOVAL_PENALTY;\n            } else {\n                currentFormat = currentFormat.replace(match, EMPTY);\n                if (match.length !== specifier.length) {\n                    var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);\n                    score -= PENALTIES[delta];\n                }\n            }\n\n            matches.push(match);\n\n            if (score < maxScore) {\n                break;\n            }\n        }\n\n        if (currentFormat.length) {\n            score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;\n        }\n\n        if (score > maxScore) {\n            maxScore = score;\n            bestMatches = matches;\n            result = availableFormats[format];\n        }\n    }\n\n    result = result.replace(\"v\", \"z\");\n\n    for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {\n        var bestMatch = bestMatches[idx$1];\n        if (bestMatch && bestMatch !== specifiers[idx$1]) {\n            var matchSpecifier = bestMatches[idx$1][0];\n            result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);\n            if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {\n                result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction cacheFormat(skeleton, format, locale) {\n    if (!resolvedFormats[locale]) {\n        resolvedFormats[locale] = {};\n    }\n    resolvedFormats[locale][skeleton] = format;\n}\n\n\nfunction skeletonFormat(skeleton, info) {\n    var availableFormats = info.calendar.dateTimeFormats.availableFormats;\n    if (availableFormats[skeleton]) {\n        return availableFormats[skeleton];\n    }\n    if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {\n        return resolvedFormats[info.name][skeleton];\n    }\n    var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);\n    var result;\n    if (timeStartIndex > 0) {\n        var dateSkeleton = skeleton.substr(0, timeStartIndex);\n        var timeSkeleton = skeleton.substr(timeStartIndex);\n\n        result = formatString(info.calendar.dateTimeFormats.short, //should be deterimed based on specifiers\n            availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),\n            availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats));\n    } else {\n        result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);\n    }\n\n    cacheFormat(skeleton, result, info.name);\n    return result;\n}\n\nfunction skeletonFromOptions(options) {\n    var result = [];\n    for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {\n        var option = DATE_OPTIONS_MAP[idx];\n        var field = option.key;\n        var value = options[field];\n        if (value) {\n            var spcifier = option.specifier || option.getSpecifier(options);\n            result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));\n        }\n    }\n\n    return result.join(EMPTY);\n}\n\nexport default function datePattern(format, info) {\n    var calendar = info.calendar;\n    var result;\n    if (isString(format)) {\n        if (calendar.patterns[format]) {\n            result = calendar.patterns[format];\n        } else {\n            result = format;\n        }\n    } else if (format) {\n        if (format.pattern) {\n            return format.pattern;\n        }\n\n        var skeleton = format.skeleton;\n        if (!skeleton) {\n            if (format.datetime) {\n                result = formatString(calendar.dateTimeFormats[format.datetime], calendar.timeFormats[format.datetime], calendar.dateFormats[format.datetime]);\n            } else if (format.date) {\n                result = calendar.dateFormats[format.date];\n            } else if (format.time) {\n                result = calendar.timeFormats[format.time];\n            } else {\n                skeleton = skeletonFromOptions(format);\n            }\n        }\n\n        if (skeleton) {\n            result = skeletonFormat(skeleton, info);\n        }\n    }\n\n    if (!result) {\n        result = calendar.patterns.d;\n    }\n\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\nvar accessors = [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"];\n\nvar Arc = function (superclass) {\n  function Arc(center, options) {\n    if (center === void 0) center = new Point();\n    if (options === void 0) options = {};\n    superclass.call(this);\n    this.setCenter(center);\n    this.radiusX = options.radiusX;\n    this.radiusY = options.radiusY || options.radiusX;\n    this.startAngle = options.startAngle;\n    this.endAngle = options.endAngle;\n    this.anticlockwise = options.anticlockwise || false;\n    this.xRotation = options.xRotation;\n  }\n\n  if (superclass) Arc.__proto__ = superclass;\n  Arc.prototype = Object.create(superclass && superclass.prototype);\n  Arc.prototype.constructor = Arc;\n\n  Arc.prototype.clone = function clone() {\n    return new Arc(this.center, {\n      radiusX: this.radiusX,\n      radiusY: this.radiusY,\n      startAngle: this.startAngle,\n      endAngle: this.endAngle,\n      anticlockwise: this.anticlockwise\n    });\n  };\n\n  Arc.prototype.setCenter = function setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n\n    this.geometryChange();\n    return this;\n  };\n\n  Arc.prototype.getCenter = function getCenter() {\n    return this.center;\n  };\n\n  Arc.prototype.pointAt = function pointAt(angle) {\n    var center = this.center;\n    var radian = rad(angle);\n    return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n  };\n\n  Arc.prototype.curvePoints = function curvePoints() {\n    var this$1 = this;\n    var startAngle = this.startAngle;\n    var dir = this.anticlockwise ? -1 : 1;\n    var curvePoints = [this.pointAt(startAngle)];\n\n    var interval = this._arcInterval();\n\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n    var subIntervalAngle = intervalAngle / subIntervalsCount;\n    var currentAngle = startAngle;\n    var transformation;\n\n    if (this.xRotation) {\n      transformation = transform().rotate(this.xRotation, this.center);\n    }\n\n    for (var i = 1; i <= subIntervalsCount; i++) {\n      var nextAngle = currentAngle + dir * subIntervalAngle;\n\n      var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n      curvePoints.push(points.cp1, points.cp2, points.p2);\n      currentAngle = nextAngle;\n    }\n\n    return curvePoints;\n  };\n\n  Arc.prototype.bbox = function bbox(matrix) {\n    var this$1 = this;\n\n    var interval = this._arcInterval();\n\n    var startAngle = interval.startAngle;\n    var endAngle = interval.endAngle;\n    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n    var extremeX = deg(extremeAngles.x);\n    var extremeY = deg(extremeAngles.y);\n    var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n    var currentAngleX = bboxStartAngle(extremeX, startAngle);\n    var currentAngleY = bboxStartAngle(extremeY, startAngle);\n    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n    var minPoint = Point.min(currentPoint, endPoint);\n    var maxPoint = Point.max(currentPoint, endPoint);\n\n    while (currentAngleX < endAngle || currentAngleY < endAngle) {\n      var currentPointX = void 0;\n\n      if (currentAngleX < endAngle) {\n        currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n        currentAngleX += 90;\n      }\n\n      var currentPointY = void 0;\n\n      if (currentAngleY < endAngle) {\n        currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n        currentAngleY += 90;\n      }\n\n      currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n\n    return Rect.fromPoints(minPoint, maxPoint);\n  };\n\n  Arc.prototype._arcInterval = function _arcInterval() {\n    var ref = this;\n    var startAngle = ref.startAngle;\n    var endAngle = ref.endAngle;\n    var anticlockwise = ref.anticlockwise;\n\n    if (anticlockwise) {\n      var oldStart = startAngle;\n      startAngle = endAngle;\n      endAngle = oldStart;\n    }\n\n    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n      endAngle += 360;\n    }\n\n    return {\n      startAngle: startAngle,\n      endAngle: endAngle\n    };\n  };\n\n  Arc.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {\n    var p1 = this.pointAt(startAngle);\n    var p2 = this.pointAt(endAngle);\n\n    var p1Derivative = this._derivativeAt(startAngle);\n\n    var p2Derivative = this._derivativeAt(endAngle);\n\n    var t = (rad(endAngle) - rad(startAngle)) / 3;\n    var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n    var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n\n    if (transformation) {\n      p1.transform(transformation);\n      p2.transform(transformation);\n      cp1.transform(transformation);\n      cp2.transform(transformation);\n    }\n\n    return {\n      p1: p1,\n      cp1: cp1,\n      cp2: cp2,\n      p2: p2\n    };\n  };\n\n  Arc.prototype._derivativeAt = function _derivativeAt(angle) {\n    var radian = rad(angle);\n    return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n  };\n\n  Arc.prototype.containsPoint = function containsPoint(point) {\n    var interval = this._arcInterval();\n\n    var intervalAngle = interval.endAngle - interval.startAngle;\n    var ref = this;\n    var center = ref.center;\n    var radiusX = ref.radiusX;\n    var radiusY = ref.radiusY;\n    var distance = center.distanceTo(point);\n    var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n    var pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n    var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n    var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n    var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n    var containsPoint;\n\n    if (intervalAngle < 180) {\n      containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n    } else {\n      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n\n      if (angle !== 360) {\n        angle = (360 + angle) % 360;\n      }\n\n      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n      containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n    }\n\n    return containsPoint;\n  };\n\n  Arc.prototype._isOnPath = function _isOnPath(point, width) {\n    var interval = this._arcInterval();\n\n    var center = this.center;\n    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n\n    if (angle !== 360) {\n      angle = (360 + angle) % 360;\n    }\n\n    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n    return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n  };\n\n  Arc.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n    // eslint-disable-line max-params\n    var arcParameters = normalizeArcParameters({\n      x1: start.x,\n      y1: start.y,\n      x2: end.x,\n      y2: end.y,\n      rx: rx,\n      ry: ry,\n      largeArc: largeArc,\n      swipe: swipe,\n      rotation: rotation\n    });\n    return new Arc(arcParameters.center, {\n      startAngle: arcParameters.startAngle,\n      endAngle: arcParameters.endAngle,\n      radiusX: arcParameters.radiusX,\n      radiusY: arcParameters.radiusY,\n      xRotation: arcParameters.xRotation,\n      anticlockwise: swipe === 0\n    });\n  };\n\n  return Arc;\n}(withAccessors(HasObservers, accessors));\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n  var cos = round((x - cx) / rx, 3);\n  var sin = round((y - cy) / ry, 3);\n  return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n  var x1 = parameters.x1;\n  var y1 = parameters.y1;\n  var x2 = parameters.x2;\n  var y2 = parameters.y2;\n  var rx = parameters.rx;\n  var ry = parameters.ry;\n  var largeArc = parameters.largeArc;\n  var swipe = parameters.swipe;\n  var rotation = parameters.rotation;\n  if (rotation === void 0) rotation = 0;\n  var radians = rad(rotation);\n  var cosine = Math.cos(radians);\n  var sine = Math.sin(radians);\n  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n  var sign = largeArc !== swipe ? 1 : -1;\n  var xt2 = Math.pow(xT, 2);\n  var yt2 = Math.pow(yT, 2);\n  var rx2 = Math.pow(rx, 2);\n  var ry2 = Math.pow(ry, 2);\n  var delta = xt2 / rx2 + yt2 / ry2;\n\n  if (delta > 1) {\n    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n    rx = delta * rx;\n    rx2 = Math.pow(rx, 2);\n    ry = delta * ry;\n    ry2 = Math.pow(ry, 2);\n  }\n\n  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2)); // due to rounding errors the value could become NaN even after radii correction\n\n  if (isNaN(constT)) {\n    constT = 0;\n  }\n\n  var cxT = constT * (rx * yT) / ry;\n  var cyT = -constT * (ry * xT) / rx;\n  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n  var uX = (xT - cxT) / rx;\n  var uY = (yT - cyT) / ry;\n  var vX = -(xT + cxT) / rx;\n  var vY = -(yT + cyT) / ry;\n  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n  var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n  if (!swipe && angle > 0) {\n    angle -= 360;\n  }\n\n  if (swipe && angle < 0) {\n    angle += 360;\n  }\n\n  var endAngle = startAngle + angle;\n  var signEndAngle = endAngle >= 0 ? 1 : -1;\n  endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n  return {\n    center: new Point(cx, cy),\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    xRotation: rotation\n  };\n}\n\nfunction bboxStartAngle(angle, start) {\n  var startAngle = angle;\n\n  while (startAngle < start) {\n    startAngle += 90;\n  }\n\n  return startAngle;\n}\n\nexport default Arc;","map":{"version":3,"names":["HasObservers","deg","rad","round","withAccessors","closeOrLess","lineIntersection","ellipseExtremeAngles","PRECISION","Point","Rect","transform","MAX_INTERVAL","pow","Math","accessors","Arc","superclass","center","options","call","setCenter","radiusX","radiusY","startAngle","endAngle","anticlockwise","xRotation","__proto__","prototype","Object","create","constructor","clone","value","_observerField","geometryChange","getCenter","pointAt","angle","radian","x","cos","y","sin","curvePoints","this$1","dir","interval","_arcInterval","intervalAngle","subIntervalsCount","ceil","subIntervalAngle","currentAngle","transformation","rotate","i","nextAngle","points","_intervalCurvePoints","push","cp1","cp2","p2","bbox","matrix","extremeAngles","extremeX","extremeY","endPoint","transformCopy","currentAngleX","bboxStartAngle","currentAngleY","currentPoint","minPoint","min","maxPoint","max","currentPointX","currentPointY","fromPoints","ref","oldStart","p1","p1Derivative","_derivativeAt","p2Derivative","t","containsPoint","point","distance","distanceTo","angleRad","atan2","pointRadius","sqrt","startPoint","intersection","calculateAngle","inAngleRange","equals","_isOnPath","width","start","end","rx","ry","largeArc","swipe","rotation","arcParameters","normalizeArcParameters","x1","y1","x2","y2","cx","cy","parameters","radians","cosine","sine","xT","yT","sign","xt2","yt2","rx2","ry2","delta","constT","isNaN","cxT","cyT","uX","uY","vX","vY","acos","angleCosine","signEndAngle","abs"],"sources":["C:/Users/asana/Documents/TEC/Semestre 5/Seguridad_Informatica/ModuloReact/Admin/frontend/node_modules/@progress/kendo-drawing/dist/es/geometry/arc.js"],"sourcesContent":["import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\n\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\n\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\n\n\nvar MAX_INTERVAL = 45;\nvar pow = Math.pow;\nvar accessors = [ \"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\" ];\n\nvar Arc = (function (superclass) {\n    function Arc(center, options) {\n        if ( center === void 0 ) center = new Point();\n        if ( options === void 0 ) options = {};\n\n        superclass.call(this);\n\n        this.setCenter(center);\n\n        this.radiusX = options.radiusX;\n        this.radiusY = options.radiusY || options.radiusX;\n        this.startAngle = options.startAngle;\n        this.endAngle = options.endAngle;\n        this.anticlockwise = options.anticlockwise || false;\n        this.xRotation = options.xRotation;\n    }\n\n    if ( superclass ) Arc.__proto__ = superclass;\n    Arc.prototype = Object.create( superclass && superclass.prototype );\n    Arc.prototype.constructor = Arc;\n\n    Arc.prototype.clone = function clone () {\n        return new Arc(this.center, {\n            radiusX: this.radiusX,\n            radiusY: this.radiusY,\n            startAngle: this.startAngle,\n            endAngle: this.endAngle,\n            anticlockwise: this.anticlockwise\n        });\n    };\n\n    Arc.prototype.setCenter = function setCenter (value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    };\n\n    Arc.prototype.getCenter = function getCenter () {\n        return this.center;\n    };\n\n    Arc.prototype.pointAt = function pointAt (angle) {\n        var center = this.center;\n        var radian = rad(angle);\n\n        return new Point(\n            center.x + this.radiusX * Math.cos(radian),\n            center.y + this.radiusY * Math.sin(radian)\n        );\n    };\n\n    Arc.prototype.curvePoints = function curvePoints () {\n        var this$1 = this;\n\n        var startAngle = this.startAngle;\n        var dir = this.anticlockwise ? -1 : 1;\n        var curvePoints = [ this.pointAt(startAngle) ];\n        var interval = this._arcInterval();\n        var intervalAngle = interval.endAngle - interval.startAngle;\n        var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n        var subIntervalAngle = intervalAngle / subIntervalsCount;\n        var currentAngle = startAngle;\n        var transformation;\n        if (this.xRotation) {\n            transformation = transform().rotate(this.xRotation, this.center);\n        }\n\n        for (var i = 1; i <= subIntervalsCount; i++) {\n            var nextAngle = currentAngle + dir * subIntervalAngle;\n            var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n            curvePoints.push(points.cp1, points.cp2, points.p2);\n            currentAngle = nextAngle;\n        }\n\n        return curvePoints;\n    };\n\n    Arc.prototype.bbox = function bbox (matrix) {\n        var this$1 = this;\n\n        var interval = this._arcInterval();\n        var startAngle = interval.startAngle;\n        var endAngle = interval.endAngle;\n        var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n        var extremeX = deg(extremeAngles.x);\n        var extremeY = deg(extremeAngles.y);\n        var endPoint = this.pointAt(endAngle).transformCopy(matrix);\n        var currentAngleX = bboxStartAngle(extremeX, startAngle);\n        var currentAngleY = bboxStartAngle(extremeY, startAngle);\n        var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n        var minPoint = Point.min(currentPoint, endPoint);\n        var maxPoint = Point.max(currentPoint, endPoint);\n\n        while (currentAngleX < endAngle || currentAngleY < endAngle) {\n            var currentPointX = (void 0);\n            if (currentAngleX < endAngle) {\n                currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\n                currentAngleX += 90;\n            }\n\n            var currentPointY = (void 0);\n            if (currentAngleY < endAngle) {\n                currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\n                currentAngleY += 90;\n            }\n\n            currentPoint = new Point(currentPointX.x, currentPointY.y);\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    };\n\n    Arc.prototype._arcInterval = function _arcInterval () {\n        var ref = this;\n        var startAngle = ref.startAngle;\n        var endAngle = ref.endAngle;\n        var anticlockwise = ref.anticlockwise;\n\n        if (anticlockwise) {\n            var oldStart = startAngle;\n            startAngle = endAngle;\n            endAngle = oldStart;\n        }\n\n        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\n            endAngle += 360;\n        }\n\n        return {\n            startAngle: startAngle,\n            endAngle: endAngle\n        };\n    };\n\n    Arc.prototype._intervalCurvePoints = function _intervalCurvePoints (startAngle, endAngle, transformation) {\n        var p1 = this.pointAt(startAngle);\n        var p2 = this.pointAt(endAngle);\n        var p1Derivative = this._derivativeAt(startAngle);\n        var p2Derivative = this._derivativeAt(endAngle);\n        var t = (rad(endAngle) - rad(startAngle)) / 3;\n        var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n        var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n        if (transformation) {\n            p1.transform(transformation);\n            p2.transform(transformation);\n            cp1.transform(transformation);\n            cp2.transform(transformation);\n        }\n\n        return {\n            p1: p1,\n            cp1: cp1,\n            cp2: cp2,\n            p2: p2\n        };\n    };\n\n    Arc.prototype._derivativeAt = function _derivativeAt (angle) {\n        var radian = rad(angle);\n\n        return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n    };\n\n    Arc.prototype.containsPoint = function containsPoint (point) {\n        var interval = this._arcInterval();\n        var intervalAngle = interval.endAngle - interval.startAngle;\n        var ref = this;\n        var center = ref.center;\n        var radiusX = ref.radiusX;\n        var radiusY = ref.radiusY;\n        var distance = center.distanceTo(point);\n        var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n        var pointRadius = (radiusX * radiusY) /\n            Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n        var startPoint = this.pointAt(this.startAngle).round(PRECISION);\n        var endPoint = this.pointAt(this.endAngle).round(PRECISION);\n        var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n        var containsPoint;\n\n        if (intervalAngle < 180) {\n            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n        } else {\n            var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n            if (angle !== 360) {\n                angle = (360 + angle) % 360;\n            }\n\n            var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\n        }\n        return containsPoint;\n    };\n\n    Arc.prototype._isOnPath = function _isOnPath (point, width) {\n        var interval = this._arcInterval();\n        var center = this.center;\n        var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n        if (angle !== 360) {\n            angle = (360 + angle) % 360;\n        }\n\n        var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\n        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n    };\n\n    Arc.fromPoints = function fromPoints (start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\n        var arcParameters = normalizeArcParameters({\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y,\n            rx: rx,\n            ry: ry,\n            largeArc: largeArc,\n            swipe: swipe,\n            rotation: rotation\n        });\n\n        return new Arc(arcParameters.center, {\n            startAngle: arcParameters.startAngle,\n            endAngle: arcParameters.endAngle,\n            radiusX: arcParameters.radiusX,\n            radiusY: arcParameters.radiusY,\n            xRotation: arcParameters.xRotation,\n            anticlockwise: swipe === 0\n        });\n    };\n\n    return Arc;\n}(withAccessors(HasObservers, accessors)));\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n    var cos = round((x - cx) / rx, 3);\n    var sin = round((y - cy) / ry, 3);\n\n    return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n    var x1 = parameters.x1;\n    var y1 = parameters.y1;\n    var x2 = parameters.x2;\n    var y2 = parameters.y2;\n    var rx = parameters.rx;\n    var ry = parameters.ry;\n    var largeArc = parameters.largeArc;\n    var swipe = parameters.swipe;\n    var rotation = parameters.rotation; if ( rotation === void 0 ) rotation = 0;\n\n    var radians = rad(rotation);\n    var cosine = Math.cos(radians);\n    var sine = Math.sin(radians);\n\n    var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n    var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n\n    var sign = largeArc !== swipe ? 1 : -1;\n\n    var xt2 = Math.pow(xT, 2);\n    var yt2 = Math.pow(yT, 2);\n    var rx2 = Math.pow(rx, 2);\n    var ry2 = Math.pow(ry, 2);\n\n    var delta = xt2 / rx2 + yt2 / ry2;\n\n    if (delta > 1) {\n        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n        rx = delta * rx;\n        rx2 = Math.pow(rx, 2);\n\n        ry = delta * ry;\n        ry2 = Math.pow(ry, 2);\n    }\n\n    var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n    // due to rounding errors the value could become NaN even after radii correction\n    if (isNaN(constT)) {\n        constT = 0;\n    }\n\n    var cxT = constT * (rx * yT) / ry;\n    var cyT = - constT * (ry * xT) / rx;\n\n    var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n    var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n\n\n    var uX = (xT - cxT) / rx;\n    var uY = (yT - cyT) / ry;\n    var vX = -(xT + cxT) / rx;\n    var vY = -(yT + cyT) / ry;\n\n    var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n\n    var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n    var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n    if (!swipe && angle > 0) {\n        angle -= 360;\n    }\n\n    if (swipe && angle < 0) {\n        angle += 360;\n    }\n    var endAngle = startAngle + angle;\n    var signEndAngle = endAngle >= 0 ? 1 : -1;\n    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\n\n    return {\n        center: new Point(cx, cy),\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: rx,\n        radiusY: ry,\n        xRotation: rotation\n    };\n}\n\nfunction bboxStartAngle(angle, start) {\n    var startAngle = angle;\n\n    while (startAngle < start) {\n        startAngle += 90;\n    }\n\n    return startAngle;\n}\n\nexport default Arc;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}